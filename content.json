{"pages":[{"title":"","text":"🎈🎈微笑墙🎈🎈 初音ミク 洛天依 图片搜集于互联网","link":"/album/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"","text":"个人简介 分享很喜欢的老罗的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：机械设计制作及其自动化想成为一名优秀的程序员(活得开心)坚信代码改变世界 博客信息 网站采用的Amazing主题 追求尽可能的简洁，清晰，易用。 大部分照搬博主的设置(十分感谢removeif博主) 博客主题相关 github Issue 作为博客微型数据库的应用 github page网站cdn优化加速 博客源码分享 博客换肤的一种实现方式思路 博客中gitalk最新评论的获取 博客图片上传picgo工具github图传使用 安装、部分配置icarus主题中文版 法律法规 法律法规数据库 中华人民共和国国旗法 中华人民共和国宪法 中华人民共和国消费者权益保护法 中华人民共和国刑事诉讼法 中华人民共和国婚姻法 中华人名共和国网络安全法 中华人民共和国劳动法 其他 网易云音乐歌单分享 计划2021计划2021.03.13 开始写博客了 参加四级考试(争取比上次成绩好点) 时间轴记录","link":"/about/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息: 网站图标：https://cdn.jsdelivr.net/gh/ZhangPF2000/Image@main/img/logo.jpg 网站名称：ZPF博客 网站地址：https://ZhangPF2000.github.io 网站简介：个人博客 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"音乐歌单收藏","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"debian10安装fcitx5","text":"摘要我把我的 debian10.8 系统的输入法换成了 fcitx5原因: fcitx4 的这个输入法不是很友好 fcitx4 不够智能的显示 我安装了 fcitx5 之后试了试,发现效果不错 更加的智能化,好多词汇都可以直接出现 而 fcitx4 中的词汇通常是固定位置,这个就比较难受了 fcitx5 的词库导入也是十分的方便,不用再去转换文件格式了 fcitx5 的皮肤更加的舒服,我再 github 上找到了我很喜欢的一个皮肤 正文 卸载 fcitx4 sudo apt remove --purge fcitx* sudo apt remove --purge *fcitx* sudo apt autoremove 卸载的时候最好退出 fcitx4 安装 fcitx5 sudo apt install --install-recommends fcitx5 fcitx5-chinese-addons --fix-missing sudo apt install --no-install-recommends fcitx5 fcitx5-chinese-addons fcitx5-frontend-gtk3 fcitx5-frontend-qt5 fcitx5-module-xorg kde-config-fcitx5 im-config 配置 fcitx5 安装完成之后就可以打开 fcitx5 默认安装完成之后,只有一堆没有的设置,需要自行设置 debian 不需要配置一些文件,修改主题输入法等相关操作都可以图形化完成 主题演示: 主题文件夹可以放在~/.local/share/fcitx5/themes/下 Alpha-white-2.0 Alpha-black Alpha-white-2.0 Alpha-white 【安然】简单白（默认皮肤圆角纯白版） 【竹子】极简花青 倬彼昊天·格子 倬彼昊天·灰色 MAC 珍珠白 白色卡片 珍珠白（无阴影版） 简约白 参考文章:Fcitx5 (简体中文)I18n Fcitx5如何现在就在 Ubuntu 20.04 用上 Fcitx 5fcitx5 的搜狗主题下载 希望能对你有所帮助(p_o)","link":"/2021/04/14/debian10%E5%AE%89%E8%A3%85fcitx5.html/"},{"title":"debian升级软件后黑屏解决","text":"debian 大升级上篇文章中升级内核时,我的推荐是不要对其他软件包进行安装防止出现黑屏,这个升级之后虽然能用,但是很不方便,所以当时我不推荐今天在使用 debian 的时候要使用 libreoffice 进行操作,发现其版本太低然后再次升级了软件包,发现还是黑屏不过上网查阅后,并通过不断的测试,还是解决了这个问题 升级 deb https://mirrors.tuna.tsinghua.edu.cn/debian/ sid main contrib non-free deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ sid main contrib non-free 我测试时是使用的 sid 源(不是太安全),你们可以考虑testing版或bullseye版国内源地址升级步骤 换源 $ sudo apt update $ sudo apt full-upgrade &amp;&amp; sudo apt upgrade sudo reboot 重启之后就再打开就可以了黑屏特点 整个开机没有任何问题,也可以登录,就是登录之后桌面是黑的 鼠标左键右键都不能用,但是好像左右键一起按有用,会弹出菜单(没有啥用) 找不到桌面设置,不能更换壁纸,不能添加部件 快捷键alt+空格打开的kruner不能使用,一直打不开 快捷键alt+f1可以打开左下角的面板,可以从里面启动程序 使用里面的程序没有任何问题,只是桌面很难看,也不能修改 没有任务栏,我的电脑开机自动连接wifi和pppoe(没升级前设置的) …… 解决办法: 注意要联网 打开终端ctrl+alt+t(我的快捷键) $ sudo apt remove plasma-* $ sudo apt remove *plasma-* $ sudo apt autoremove $ sudo apt install plasma-* $ sudo reboot 我推测好像是升级的时候,plasma 的软件和设置出现了问题 导致 plasma 软件和设置不能其作用,导致桌面不能显示 按照上面的方法,重启之后,再登录就可以显示桌面了 当初还遇到一种情况:桌面可以设置壁纸(右上角有个小东西,点击可以设置桌面) 但是没有任务栏,默认面板也不能使用(原因估计和这个一样(没试过)) 重启之后,一切基本都好了,剩下的再慢慢的配置下就好了,然后再备份下 升级后感觉如何 升级完成之后发现这些配置是真的爽 更加方便的设置 更加完善的默认软件(设置有个护眼的很棒[debian 太亮了,不适应,还是暖色好]) 更加好看的系统(主要都是在一些小地方,但是很实用的) 我升级的是 sid 版本,都是最新的,也不知道有没有啥大问题,但是目前感觉不错 软件的整体升级,这个就很舒服了,好多软件在稳定版上都是太老了,界面,功能都很少 我以前使用 kubuntu 的时候,用的也很舒服,那些都是自动设置的,不过 debian 是自行升级的 默认版本的还是太稳了,稳如老狗啊 想要 kubuntu 那种新版软件和新感觉的可以考虑升级一下 注意事项 一定要备份,这个最为重要,失败了可以恢复,不然就玩了 一定要联网,下载 plasma 包的时候要用 升级后图片 希望能对你有所帮助(p_o)","link":"/2021/04/03/debian%E5%8D%87%E7%BA%A7%E8%BD%AF%E4%BB%B6%E5%90%8E%E9%BB%91%E5%B1%8F%E8%A7%A3%E5%86%B3.html/"},{"title":"fcitx使用搜狗皮肤","text":"如果你需要 fcitx5,请看后面的文章我升级了输入法,fcitx5 的效果要更好,我推荐使用 fcitx5链接 fcitx 使用搜狗皮肤 前往https://github.com/jorhelp/Fcitx_Skin下载脚本文件git clone https://github.com/jorhelp/Fcitx_Skincd Fcitx_Skin去https://pinyin.sogou.com/skins/下载皮肤到Fcitx_Skin文件夹下./ssf2fcitx.py xxx.ssf将生成的文件夹放到~/.config/fcitx/skin下,重启 fcitx 选择皮肤即可如果使用的时候有部分偏差,请自行修改生成的fcitx_skin.conf或skin.ini等文件 参考文章:脚本链接 希望能对你有所帮助(p_o)","link":"/2021/04/11/fcitx%E4%BD%BF%E7%94%A8%E6%90%9C%E7%8B%97%E7%9A%AE%E8%82%A4.html/"},{"title":"fcitx使用搜狗词库","text":"如果你需要 fcitx5,请看后面的文章我升级了输入法,fcitx5 的效果要更好,我推荐使用 fcitx5链接 fcitx 使用搜狗词库 简介: 在使用 debian 的时候,我是使用的 fcitx 框架+google 输入法但是这个 fcitx 不是特别的好用,输入的时候没有在 win10 输入法的那种舒服感至于词库,在输入的时候,不是特别的好用,今天无意间看到 fcitx 可以使用搜狗的词库就试了试,下面是我的操作步骤 手动设置 &amp;&amp; 自动配置 手动配置 下载搜狗词库文件,下载的文件格式是*.scel 这个格式的文件 fcitx 是无法使用的,fcitx 的词库文件是*.mb文件 将scel转换为mb格式 sudo apt install fcitx-tools 这是转换工具 scel2org xxx.scel -o xxx.org 转换成 org 文件, org 文件是可以查看的 cat *.org &gt; tot.org 合并转换的 org 文件, 下载下面的两个文件gbkpy.org和pyPhrase.org https://raw.githubusercontent.com/LuoshuiTianyi/Varia/master/gbkpy.org https://raw.githubusercontent.com/LuoshuiTianyi/Varia/master/pyPhrase.org cat pyPhrase.org &gt;&gt; tot.org 词汇合并 sort tot.org &gt; ord.org 排序 uniq ord.org &gt; final.org 去重复 createPYMB gbkpy.org final.org 生成 mb 文件 cp *.mb ~/.config/fcitx/googlepinyin 将生成的 mb 文件复制到配置文件下 重启 fcitx 即可 批量下载搜狗词库的爬虫 自动配置 下载地址下载现成的文件也可以,上面的下载后也是两个mb文件,将这两个文件放到~/.config/fcitx/googlepinyin下重启即可这两个文件,应该是整合了很多的词库的,可以使用的 参考文章:Fcitx 使用搜狗词库与皮肤 希望能对你有所帮助(p_o)","link":"/2021/04/11/fcitx%E4%BD%BF%E7%94%A8%E6%90%9C%E7%8B%97%E8%AF%8D%E5%BA%93.html/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/03/12/hello-world.html/"},{"title":"hexo Github双分支","text":"摘要 上一篇文章中,已经成功了搭建好了博客,也可以发布了,但是只能在当前操作系统进行发布,这个就不是很方便,尤其是我的操作系统还是一个U盘系统,多数情况下可能还是使用windows等,这个时候把我的hexo配置等存储在Github就很不错,而且hexo初始化的时候还有一个.gitignore文件就是为了这种情况考虑的.而且github支持分支进行分别存储,这样就更加的方便了 目录结构 双分支 创建hexo分支 修改hexo分支为主分支 注意:此时的hexo为主分支,且hexo分支内含有博客文件(原main分支的内容,不用在意) 本地操作 克隆仓库 [git提交])(#git提交) 推送到远程仓库:git push origin hexo 查看 推送完成之后就可以去github上查看是否完成 推送之后,检查一下自己的博客是否还能打开 我记得我创建完hexo分支后,博客就打不开了,后来推送完在查看就又可以了 你们的视情况而定(p_o) 一定要多动手,多操作,出错了,多百度解决问题 如果糊涂了,就删了仓库再来一遍(我好像就删了一次仓库) 双分支 基于我的hexo配置,生成的博客都是在&lt;username&gt;.github.io的main分支上的,main也是我仓库的主分支我打算在github上创建一个hexo分支去存放我的hexo配置文件并且设置hexo为主分支(git默认只克隆主分支) 克隆仓库 克隆仓库1234567891011$ cd ~/Desktop$ lsBlog$ git clone https://github.com/&lt;username&gt;/&lt;username&gt;.github.io.git$ lsBlog &lt;username&gt;.github.io#-------------# Blog是我们的hexo初始化的文件夹# &lt;username&gt;.github.io是我们刚克隆下来的仓库# 这个仓库的分支是hexo分支 git提交 git提交123456789101112131415161718192021222324252627282930313233$ lsBlog &lt;username&gt;.github.io$ cp &lt;username&gt;.github.io/.git ./Blog/ -r$ cd Blog$ git statusxxxxxxxxxx$ git add .$ git commit -m &quot;hexo初始化提交&quot;#--------------# cp &lt;username&gt;.github.io/.git ./Blog/ -r是将.git文件夹拷贝到Blog文件夹中# git status是显示文件的状态 # 大致分为两类 # 一类是,xxx文件/文件夹被删除了--&gt;对应着&lt;username&gt;.github.io里面的文件 # 一类是,xxx文件/文件夹被添加了--&gt;对应着Blog里面的文件# git add .# 这条是将所有的更改(修改/删除/创建)保存到暂存区# git commit -m &quot;xxx&quot; 是将更改提交到工作区#--------------# 注意事项$ cat .gitinore.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/# 如果Blog下没有.gitinore这个文件,创建并添加上面的内容# 如果有,内容不是上面的,修改成上面的内容(这是hexo初始化自带的)# 这个.gitinore文件可以让git屏蔽一些文件和文件夹(都是没啥用的) 参考文章:hexo+yilia主题优化及双分支部署基于Github双分支和Hexo搭建博客","link":"/2021/03/16/hexo-Github%E5%8F%8C%E5%88%86%E6%94%AF.html/"},{"title":"前几天的意见烦心事","text":"生活琐事 前几天不小心在操作kubuntu的grub时不小心把引导文件删除了之后在win10上恢复,结果不小心把kubuntu系统给删除掉了其实只要打开vmware开启一个linux系统插上u盘把分区挂载到linux上重建grub就可以了可惜我是个菜鸟….当我想到的时候,再挂载却发现什么文件都没了……….伤心….里面还有我的两篇blog呢(其中一篇我特用心,特别长)后悔啊……. =============在此涨个记性,grub坏了,只要系统文件没坏,还是可以很轻松搞定的不要再到win10上去使用乱七八糟的软件来打开分区进行恢复(我在kubuntu中备份了grub文件)后面的事情………..kubuntu失去了之后,我打算安装debian(我还是比较喜欢这个)只不过当时安装debian之后,发现出现了些问题,在vmware可以打开桌面插上电脑之后,引导打开之后发现无法进入桌面,当时太菜了,无法解决这个问题查了一些文章发现,好像是nvidia显卡和debian默认驱动的问题后来想着kubuntu也没了,再试试…按照debian快速安装来安装按照Debian 10.2命令安装Nvidia显卡驱动成功，问题回顾来进行修改 注意事项:我的debian是目前最新版debian10.8版本我的电脑是使用的pppoe拨号进行连接上网的u盘插上电脑启动之后无法进入桌面,也就无法联网(我推测没有桌面都不能上网)我电脑上有个wifi网卡,但是debian也无法检测到(后续再说)但是在vmware上是有桌面的,可以联网(上面的教程是要联网下载软件之类的)上面的教程要反复进行在电脑和vmware上打开(查看一些电脑数据之类的)debian10.8版本的系统内核版本好像是4.19(稳定版本的)但是这个版本有点老了(我后来更新到了5.10版本) 按照上面的教程基本就可以在电脑上打开u盘中的debian了debian和kubuntu对比 debian更加的古老…….我使用的还是kde但是感觉debian的更加舒服debian的汉化会更好,好多都汉化了,kubuntu还有好多没汉化debian更加的复杂些,我现在遇到了很多的问题而这些问题基本上在kubuntu都解决了(驱动问题)kubuntu的好多软件和内核都比较新内核版本比debian高太多了debian的4.19太低了,好多软件功能都没有,也没有kubuntu的好看所以后来我升级到了5.10版本(这个过程也遇到了很多问题)debian对于驱动问题有点大,4.19内核不支持我的wifi网卡ax200这个只能升级内核版本才能解决而kubuntu安装完成之后打开就都解决了,开机即可使用不停的备份系统,不停的测试解决问题这个过程还是很享受的,也学到了很多知识,我还是更喜欢这种动手琢磨的感觉吧希望这个debian能成为我未来的主力电脑","link":"/2021/04/01/%E5%89%8D%E5%87%A0%E5%A4%A9%E7%9A%84%E6%84%8F%E8%A7%81%E7%83%A6%E5%BF%83%E4%BA%8B.html/"},{"title":"升级debian内核","text":"原因debian10.8 版本安装完成之后默认安装的是 4.19 内核,不过这个内核已经有点老了还不支持一些的硬件:我的 wifi 网卡不能被识别到上网查阅资料得知:要识别到网卡需要 5.12 的内核(cf-ax200 无线网卡)升级内核后安装驱动重启即可 重要的事情说三遍备份数据 备份数据 备份数据 我使用的是 timeshift 软件进行备份很简单的就可以完成对 debian 系统内所有文件的备份(注意硬盘容量)我在升级内核的时候,遇到了好多次失败,所以备份是一个重要的良好的习惯 升级内核 首先换源其次sudo apt update不要使用sudo apt upgrade然后sudo apt list --upgradable | grep &quot;linux-image&quot;找到可升级的内核sudo apt upgrade xxx升级内核 由于我的电脑是 nvidia 显卡,参考Debian 10.2 命令安装 Nvidia 显卡驱动成功，问题回顾之后就可以打开桌面了但是在升级内核的时候遇到了些问题大致就是升级内核之后,更新 grub,以新内核进行启动会无法加载 nvidia 模块之类的,总之就是无法打开桌面经过我的测试发现,按照上面的教程确实可以解决 nvidia 的显卡问题,但是升级内核之后这些配置就成了阻碍打开桌面的原因了 解决办法 sudo apt remove –purge nvidia* sudo apt remove –purge *nvidia* sudo apt autoremove 上面的设置是去除所有的 nvidia 设置和包 sudo rm /etc/X11/xorg.conf sudo rm /usr/local/bin/switch_nvidia.sh 打开/usr/share/sddm/scripts/Xsetup 去除/usr/local/bin/switch_nvidia.sh这一行 我的是 sddm,这些是修改内核加载模块顺序(我猜的) 上面的完成之后重启应该就可以以新内核打开桌面了 注意: 我一直使用的都是默认开源内核 nouveau, 不需要禁用 重启之后进入桌面链接网络(我的 pppoe 拨号)总之联网然后 sudo apt update &amp;&amp; sudo apt upgrade 更新一下换源 bullseye 版本然后安装firmware-iwlwifi模块(使用bullseye版源更新)重启后就可以看到 wifi 了sudo apt update &amp;&amp; sudo apt install firmware-iwlwififirmware-iwlwifi 这个模块的稳定版中版本有点低不能用,所以要换源提醒:不要随便升级包,我把我的源换成了 sid(unable:不可靠的)后更新(已解决)发现能进入桌面,但是好多的设置都变了,桌面没了,任务栏没了,我也设置不好所以我又换成了以前的源(稳定版),必要的时候使用其他源总之就是不要随便更新源尤其是不稳定的源(如果要更新,请提前备份数据)上面划线的已解决,请看下一篇文章防止出现问题后无法恢复导致只能重新安装 ==================================================================升级内核后遇到的问题升级之后,确实可以使用 wifi 了,桌面设置之类的也没有太大变化不过我发现 firefox 和 chrome 不能输入中文了大致就是在终端启动 firefox 之后,会显示加载 xxx 失败还有个 xx 版本太老(我忘了.写博客的时候已经修改好了,我使用的备份,也没有我的搜索记录了)这个的解决办法就是彻底卸载 fcitx,然后再安装上注意顺序是先安装 firmware-iwlwifi 再安装 fcitx,不然会冲突如果已经安装了 fcitx 就卸载 12345678910111213sudo apt remove --purge fcitx*sudo apt remove --purge *fcitx*sudo apt autoremove# 上面是卸载fcitxsudo apt install fcitx-frontend-gtk2 fcitx-frontend-gtk3 fcitx-ui-classic fcitx-ui-lightsudo apt install fcitx-sunpinyin fcitx-googlepinyinsudo apt install fcitx-table*sudo apt install fcitx-frontend-qt4 fcitx-frontend-qt5sudo apt install kde-config-fcitx fcitx-module-cloudpinyin# 这些是安装fictx和一些配置(我找不到参考文档了)# 上面这些基本都是必备的# 最后一行的是安装kde中fcitx的配置文件,可以在设置中找到fcitx# fcitx-module-cloudpinyin是可以使用云拼音 我的 debian 源 稳定版 debian 源12345678deb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster main contrib non-freedeb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-updates main contrib non-freedeb https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ buster-backports main contrib non-freedeb https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security buster/updates main contrib non-free bullseye 版1234567891011121314# 当buster版(稳定版)的源不支持你的软件时,可以考虑这个源# 这个还是比较常用的,毕竟debian的稳定版源有些软件太老了# 使用该源的时候,可以sudo apt update# 但是不要sudo apt upgrade,这会导致软件全部升级,可能会出现未知错误# 需要更新的时候请先sudo apt update# 然后sudo apt install xxx 或者 sudo apt upgrade xxxdeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-freedeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-freedeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-freedeb https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free testing 版123456789# 这个是测试版的源deb https://mirrors.tuna.tsinghua.edu.cn/debian/ testing main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ testing main contrib non-freedeb https://mirrors.tuna.tsinghua.edu.cn/debian/ testing-updates main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ testing-updates main contrib non-freedeb https://mirrors.tuna.tsinghua.edu.cn/debian/ testing-backports main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ testing-backports main contrib non-freedeb https://mirrors.tuna.tsinghua.edu.cn/debian-security testing-security main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security testing-security main contrib non-free sid 版123# 这个最不稳定不要随便用deb https://mirrors.tuna.tsinghua.edu.cn/debian/ sid main contrib non-freedeb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ sid main contrib non-free 希望能对你有所帮助(p_o)","link":"/2021/04/02/%E5%8D%87%E7%BA%A7debian%E5%86%85%E6%A0%B8.html/"},{"title":"解决debian升级内核后新内核无法启动的问题","text":"我整体的升级了我的 debian10使用了 bullseye 版的源去升级软件和内核升级之后我的内核版本是Linux debian 5.10.0-6-amd64 #1 SMP Debian 5.10.28-1 (2021-04-09) x86_64 GNU/Linux但是使用这个内核重启系统之后会出现引导错误连桌面都进不去但是其他的内核可以进去我使用的是 5.10.0-5-amd64 内核就可以进入系统可见出现问题的地方是 linux 的内核 错误图片 解决问题分析问题因为我使用的是 grub2 进行系统引导的在我升级内核之后就更新了我的 grub2 配置文件update-grub2由于是内核的问题,我就先找 debian 的启动内核vmlinuz-5.10.0-5-amd64和initrd.img-5.10.0-5-amd64这两个文件是在/boot文件夹下的在/boot/grub/grub.cfg文件中查找时发现了启动错误的地方配置文件如下 grub2错误内核启动的配置123456789101112131415menuentry 'Debian GNU/Linux' --class debian --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-simpl-axxxxxxx--xxxx-xxxx-xxxxxxxxxxx6' { load_video insmod gzio if [ x$grub_platform = xxen ]; then insmod xzio; insmod lzopio; fi insmod part_gpt insmod ext2 set root='hd1,gpt2' if [ x$feature_platform_search_hint = xy ]; then search --no-floppy --fs-uuid --set=root --hint-bios=hd1,gpt2 --hint-efi=hd1,gpt2 --hint-baremetal=ahci1,gpt2 axxxxxxxx--xxxx-xxxx-xxxxxxxxxxx6 else search --no-floppy --fs-uuid --set=root axxxxxxxx--xxxx-xxxx-xxxxxxxxxxx6 fi echo 'Loading Linux 5.10.0-6-amd64 ...' linux /boot/vmlinuz-5.10.0-6-amd64 root=/dev/sdb2 ro quiet} 仔细对比发现这个 grub2 加载内核出问题了因为 grub2 是通过加载 linux 内核启动系统的但是这个配置文件中却没有新内核的加载与之相对的是旧内核的加载:如下 grub2加载旧内核部分配置文件1234567891011121314151617menuentry 'Debian GNU/Linux, with Linux 5.10.0-5-amd64' --class debian --class gnu-linux --class gnu --class os $menuentry_id_option 'gnulinux-5.10.0-5-amd64-advanced-axxxxxxxx--xxxx-xxxx-xxxxxxxxxxx6' { load_video insmod gzio if [ x$grub_platform = xxen ]; then insmod xzio; insmod lzopio; fi insmod part_gpt insmod ext2 set root='hd1,gpt2' if [ x$feature_platform_search_hint = xy ]; then search --no-floppy --fs-uuid --set=root --hint-bios=hd1,gpt2 --hint-efi=hd1,gpt2 --hint-baremetal=ahci1,gpt2 axxxxxxxx--xxxx-xxxx-xxxxxxxxxxx6 else search --no-floppy --fs-uuid --set=root axxxxxxxx--xxxx-xxxx-xxxxxxxxxxx6 fi echo 'Loading Linux 5.10.0-5-amd64 ...' linux /boot/vmlinuz-5.10.0-5-amd64 root=UUID=axxxxxxxx--xxxx-xxxx-xxxxxxxxxxx6 ro quiet echo 'Loading initial ramdisk ...' initrd /boot/initrd.img-5.10.0-5-amd64 } 这个最后四行中,有两行是加载 linux 内核启动系统的分别是linux /boot/vmlinuz-5.10.0-5-amd64和initrd /boot/initrd.img-5.10.0-5-amd64查看/boot文件夹下的内容 boot文件夹下的内容12zpf@debian:~/Desktop/Blog$ ls /boot/config-5.10.0-5-amd64 efi initrd.img-5.10.0-5-amd64 System.map-5.10.0-5-amd64 vmlinuz-5.10.0-5-amd64 grub 里面竟然没有新内核的文件查看 apt 安装的内容发现已经安装了,这个时候已经知道问题所在了就是升级内核之后,内核丢失,需要重新安装 解决办法 重新安装新内核终端执行下面的命令sudo apt reinstall linux-image-5.10.0-6-amd64重装之后记得查看/boot文件夹下有没有内核文件这个时候重启即可 重装之后boot文件夹下的内容123zpf@debian:~/Desktop/Blog$ ls /boot/config-5.10.0-5-amd64 efi initrd.img-5.10.0-5-amd64 System.map-5.10.0-5-amd64 vmlinuz-5.10.0-5-amd64config-5.10.0-6-amd64 grub initrd.img-5.10.0-6-amd64 System.map-5.10.0-6-amd64 vmlinuz-5.10.0-6-amd64 希望能对你有所帮助(p_o)","link":"/2021/04/27/%E8%A7%A3%E5%86%B3debian%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8%E5%90%8E%E6%96%B0%E5%86%85%E6%A0%B8%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%E7%9A%84%E9%97%AE%E9%A2%98.html/"},{"title":"01_学习Shell之前初步了解linux系统","text":"摘要根据书中的目录,学习 shell 之前先了解什么是 linux 系统和 linux 系统的基本使用本篇文章主要是关于 linux 的文件系统的基础介绍和 shell 初了解 linux 文件系统基础介绍 在 linux 系统中,一切都可以用文件来表示,所以了解 linux 文件系统还是很重要的常见的文件系统: fat 系列 ntfs ext 系列 我的 debian 系统就是 ext4 格式的这是一种日志文件系统使用该文件系统保存时,除了保存内容之外还有相关内容的属性和权限之类的在 linux 系统中,一般使用结点(inode)的方式存储文件 题外话 磁盘中的最小存储单元是扇区,每个扇区有 512 个字节,因为扇区特别多,不利于文件内容的存储,因此在 linux 系统中,实际上是按照块的方式进行存储的,一般来说一个块由 8 个扇区构成,在块中,存储着文件的相关信息这些存储文件基本信息的区域称为inode,即索引结点 索引结点(inode)的内容 文件的大小 文件的创建者,使用 ID 表示 文件的所属组 文件的读写执行权限 文件的时间属性 链接数 文件中数据 block 的位置 每个 inode 的大小一般为 128 字节或 256 字节可以使用 stat 命令查看结点信息举例 123456789zpf@debian:~/Desktop/Blog$ stat public/ 文件：public/ 大小：4096 块：8 IO 块：4096 目录设备：812h/2066d Inode：1048607 硬链接：19权限：(0755/drwxr-xr-x) Uid：( 1000/ zpf) Gid：( 1000/ zpf)最近访问：2021-04-21 21:03:48.431319597 +0800最近更改：2021-04-21 21:03:48.423319545 +0800最近改动：2021-04-21 21:03:48.423319545 +0800创建时间：2021-04-21 21:03:45.435300083 +0800 linux 系统文件结构 linux 使用的是树型结构存储文件的linux 系统的根目录是用/表示 目录名称 作用 / 系统的根目录,包含系统中其他的所有文件 root root 用户的主目录 home 存放普通用户的相关文件 bin 存放常用命令的目录,如 ls sbin 要具有一定权限才可以使用命令 proc 这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息 usr 安装一个软件的默认目录 boot 存放引导系统启动的相关文件 lib 库文件 静态库/动态库/内核模块文件 etc 存放配置的相关文件,像 apt 配置文件(/etc/apt/source.list) var 存放经常变化的文件，如网络连接的 sock 文件 、日志 mnt 默认挂载光驱和软驱的目录,可挂载其他设备(需提前创建文件夹) tmp 这个目录是用来存放一些临时文件的 opt 可选目录，第三方程序的安装目录 我们通常用到的目录home/usr/var/etc/等等 走进 shell shell 的中文意思是’贝壳’在 linux 中的意思’贝壳’保护内核内核通常是脆弱的,shell 是可以直接和内核交互的用户通过 shell 与内核交互 本质上 shell 是个命令解释器,把用户的请求解释为内核能处理的内容因此 shell 对 linux 是十分重要的,学习 shell 也是十分有必要的在 shell 中也是有着十分复杂的语法的,像选择,循环,判断等等Shell 也是有着很多种类的,linux 默认的 shell 是 bashecho $SHELL查看 shell 类型debian 就是使用的 bash shell 就是命令行的操作,写在文件中,通过 bash 进行解释运行注释: 使用#进行单行注释符号#!的使用,这个是告诉要使用那种 shell 终端使用那个 shell 执行该脚本#! /bin/bash执行 shell 脚本需要将脚本赋予执行权限chmod u+x filename终端执行 shell 脚本 ./filename shell名称 脚本名称 上面的内容差不多就是书中前两章的内容因为我有了一定的基础,就看的比较快,也能理解书中的内容 希望能对你有所帮助(p_o)","link":"/2021/04/22/Linux_Bash/01_%E5%AD%A6%E4%B9%A0Shell%E4%B9%8B%E5%89%8D%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3linux%E7%B3%BB%E7%BB%9F.html/"},{"title":"02_看书学习shell_bash总结","text":"摘要本来打算学着书写着博客呢结果这几天事有点多,没时间写但是有时间看书,书看完了,但博客也还没写尴尬了………. 看完这本书的感受: 这是一本适合初学者的书 这本书很基础,好多的内容都可以理解 这本书后面有点高级,不过目前我还没用到 书看完了,再写博客效果也差了点 所以我打算不写关于这本书的博客了 但是这个 bash 专栏的博客还是会写的 会记录一些我遇到的一些 nb 的脚本和知识 我目前在codewars练习我的代码水平 在上面我填写了 bash 选项,目前整体水平是5kyu而 shell 是7kyu 上面的代码很有水平,能有效的提高我的代码水平 关于我的大部分代码都是在codewars专栏这说明了 这里就会更新很慢了 特此说明一下 希望能对你有所帮助(p_o)","link":"/2021/04/28/Linux_Bash/02_%E7%9C%8B%E4%B9%A6%E5%AD%A6%E4%B9%A0shell_bash%E6%80%BB%E7%BB%93.html/"},{"title":"Linux_Bash_学习之路","text":"摘要现在开始一系列新的文章用于记录我学习 linux_Bash 的过程学习 linux Bash 脚本是为了更好的了解 linux 和方便日常的操作自动化的使用脚本能够节省更多的时间去做事情举例: 我写博客使用的是 hexo,可以创建两个脚本文件s.sh和d.sh用于预览博客和推送博客到 github 上使用的时候就直接运行脚本即可 Bash 脚本构成中全是 linux 中的命令在学习过程中能更好的学习 linxu 命令我借用了学校图书馆中的书来辅助我的学习书籍信息: 书名: Linux Bash 编程与脚本应用实战 ISBN: 978-7-302-38446-5 封面: 目前这本书我已经看了一半了还可以,难度也不是太大但是在学习的过程中,发现书里面的命令在我的电脑上的结果和书中的不一样书的前面介绍了很多 linux 的基础知识,很不错有好些知识是我还没了解过的,看完前面的对后面的脚本编写有很大的好处这几天把这本书的内容学学,并且通过 blog 的方式记录下来我估计这本书很快就可以学完了,学完之后再学学其他借的基本书:Linux从入门到精通和Linux操作系统(感觉还不错的样子) 书的目录第 01 章: 学习 Shell 的背景知识—linux 系统第 02 章: 迈出 Shell 脚本编程第一步第 03 章: Shell 常用命令大演练第 04 章: Shell 脚本中的变量第 05 章: Shell 脚本中的特殊符号第 06 章: Linux 中的文件处理第 07 章: Shell 脚本中的分支结构第 08 章: Shell 中的循环结构第 09 章: Shell 中的函数第 10 章: Shell 脚本编写技巧第 11 章: 正则表达式第 12 章: Shell 中的文本搜索工具—grep 家族第 13 章: sed 编程第 14 章: gawk 编程第 15 章: 脚本控制第 16 章: 脚本运行的优化第 17 章: Shell 实战之系统管理第 18 章: Shell 实战之数据库操作 该书是使用的 ubuntu 系统,整体来说,区别不是太大 希望能对你有所帮助(p_o)","link":"/2021/04/21/Linux_Bash/Linux_Bash_%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF.html/"},{"title":"01_cpp_返回字符串中的最大值和最小值","text":"题目链接内容介绍: 12345678910111213In this little assignment you are given a string of space separated numbers, and have to return the highest and lowest number.Example:highAndLow(&quot;1 2 3 4 5&quot;); // return &quot;5 1&quot;highAndLow(&quot;1 2 -3 4 5&quot;); // return &quot;5 -3&quot;highAndLow(&quot;1 9 3 4 -5&quot;); // return &quot;9 -5&quot;Notes: All numbers are valid Int32, no need to validate them. There will always be at least one number in the input string. Output string must be two numbers separated by a single space, and highest number is first. 我的解决方案 for 循环遍历字符串中的每个字符 通过判断将字符组成新的字符串(数字字符串) 把这些数字字符串放入容器 vector 中 依次弹出容器中的字符串,转换成数字 进行数字比较,确定最小值和最大值 返回最大值和最小值我的提交代码如下 我的解决方案 >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;string&gt;#include &lt;vector&gt;int test(std::string s){ bool tag = true; int num = 0; /* code */ for (size_t i = 0; i &lt; s.length(); i++) { /* code */ if (s[i] == '-') { tag = false; continue; } num = num * 10 + (s[i] - 48); } num = tag ? num : num * -1; return num;}std::string highAndLow(const std::string&amp; numbers){ //your code here int num = 0; int num_min = 0, num_max = 0; std::vector&lt;std::string&gt; vs; std::string str = &quot;&quot;; for (size_t i = 0; i &lt;= numbers.length(); i++) { if (numbers[i] != ' ' &amp;&amp; (numbers[i] == '-' || (48 &lt;= numbers[i] &amp;&amp; numbers[i] &lt;= 57))) { str = str + numbers[i]; } else if (numbers[i] == ' ' || numbers[i] == '\\0') { vs.push_back(str); str = &quot;&quot;; } else { str = &quot;&quot;; continue; } } std::string s1 = &quot;&quot;, s2 = &quot;&quot;; num_max = num_min = test(vs[0]); for (size_t i = 0; i &lt; vs.size(); i++) { num = test(vs[i]); std::cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; std::endl; s1 = ((num &lt;= num_min) ? vs[i] : s1); s2 = ((num &gt;= num_max) ? vs[i] : s2); num_min = ((num &lt; num_min) ? num : num_min); num_max = ((num &gt; num_max) ? num : num_max); num = 0; } str = s2 + ' ' + s1; return str;} 我的方案还是不好,代码篇幅太大空间时间复杂度都比较高思路没有问题,但是还可以再优化 优化方案 >folded1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;limits&gt;#include &lt;string&gt;int test(std::string s){ bool tag = true; int num = 0; /* code */ for (size_t i = 0; i &lt; s.length(); i++) { /* code */ if (s[i] == '-') { tag = false; continue; } num = num * 10 + (s[i] - 48); } num = tag ? num : num * -1; return num; }std::string highAndLow(std::string numbers){ //your code here int num = 0; int num_min = std::numeric_limits&lt;int&gt;::max(), num_max = std::numeric_limits&lt;int&gt;::min(); // 这个是让num_min=int范围内的最大值,num_max=int范围内的最小值 std::string str = &quot;&quot;; std::string s1 = &quot;&quot;, s2 = &quot;&quot;; for (size_t i = 0; i &lt;= numbers.length(); i++) { if (numbers[i] != ' ' &amp;&amp; (numbers[i] == '-' || (48 &lt;= numbers[i] &amp;&amp; numbers[i] &lt;= 57))) { str = str + numbers[i]; } else if (numbers[i] == ' ' || numbers[i] == '\\0') { num = test(str); s1 = ((num &lt;= num_min) ? str : s1); s2 = ((num &gt;= num_max) ? str : s2); num_min = ((num &lt; num_min) ? num : num_min); num_max = ((num &gt; num_max) ? num : num_max); str=&quot;&quot;; } else { str = &quot;&quot;; continue; } } str = s2 + ' ' + s1; return str;} 上面这个解决方案中舍弃了容器,直接让确定的数字字符串转换成数字返回然后进行比较不过这个使用了&lt;limits&gt;这个头文件是为了让比较的初始值为最大(num_min)和最小(num_max)防止出现无法比较的情况,这个方案就比上面那个要好很多了 大佬的解决方案大佬的解决方案123456789101112131415161718192021222324252627282930313233#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;limits&gt;std::string highAndLow(const std::string&amp; numbers){ std::stringstream ss(numbers); int temp, min = std::numeric_limits&lt;int&gt;::max(), max = std::numeric_limits&lt;int&gt;::min(); while (ss &gt;&gt; temp) { min = (temp &lt; min) ? temp : min; max = (temp &gt; max) ? temp : max; }; return std::to_string(max) + &quot; &quot; + std::to_string(min);}/** * 这里主要是使用了#include &lt;sstring&gt;头文件 * 以下是我的对sstring的推测 * 头文件中的stream是流的意思 * 常见的有iostream(标准输入输出流),和fstream(文件输入输出流) * iostream中有istream和ostream两个常见的类 * fstream中有fstream,ifstream,ofstream三个类(常见的) * 推测sstream是字符串流处理,专门处理字符串流的 * sstream有stringstream,istringstream和ostringstream三个类 * 用法和上面的fstream差不多,也支持`&gt;&gt;`和`&lt;&lt;`运算符 * * 上面大佬的解决思路大致就是 * 把传入的字符串传入字符串流ss中, * ss &gt;&gt; temp是把字符串流中的数据输入到temp(int类型)中 * 然后进行比较判断,最后把最大数和最小数转换成字符串 * * `&gt;&gt;` 这个具有和std::cin &gt;&gt; test差不多的特性 * 输入空格后就停止,然后进行下一个*/ 学到的知识点 #include &lt;sstring&gt;#include &lt;limits&gt;主要是sstring头文件,以后可以方便的处理字符串数据可以多了解了解这个头文件中的类,函数sstring举例 sstring例子12345678910111213#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;iostream&gt;int main(){ std::stringstream stream; std::string result; int i = 1000; stream &lt;&lt; i; //将int输入流 stream &gt;&gt; result; //从stream中抽取前面插入的int值 std::cout &lt;&lt; result &lt;&lt; std::endl; // print the string &quot;1000&quot;} 希望能对你有所帮助(p_o)","link":"/2021/04/24/codewars/01_cpp_%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC.html/"},{"title":"02_shell_返回字符串中重复字符的个数","text":"题目链接内容介绍 1234567891011121314151617Count the number of DuplicatesWrite a function that will return the count of distinct case-insensitive alphabetic characters and numeric digits that occur more than once in the input string. The input string can be assumed to contain only alphabets (both uppercase and lowercase) and numeric digits.Example&quot;abcde&quot; -&gt; 0 # no characters repeats more than once&quot;aabbcde&quot; -&gt; 2 # 'a' and 'b'&quot;aabBcde&quot; -&gt; 2 # 'a' occurs twice and 'b' twice (`b` and `B`)&quot;indivisibility&quot; -&gt; 1 # 'i' occurs six times&quot;Indivisibilities&quot; -&gt; 2 # 'i' occurs seven times and 's' occurs twice&quot;aA11&quot; -&gt; 2 # 'a' and '1'&quot;ABBA&quot; -&gt; 2 # 'A' and 'B' each occur twice/** * 给定一个字符串 * 忽略字符的大小写,字符串中只有英文字母和数字 * 返回里面有几个字符是重复的*/ 我的解决方案通过把字符串拆成单个字符判断字符的重复个数比较返回代码掩饰 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#! /bin/bashfunction count{ if [ -z $1 ] ; then echo '空字符串' return 0 fi # 这些是获取字符串的长度的方法 #echo $1 | wc -c #var=$1 #echo ${#var} #expr length $1 # 循环遍历把每个字符放到数组中 for((i=1;i&lt;=$(expr length $1); i++)) do #echo $(echo $1 | cut -b $i) Arr[i-1]=`echo $1 | cut -b $i` done # echo Arr[@]是打印出数组中所有的内容,以空格区分 test=$(echo ${Arr[@]} | tr &quot; &quot; &quot;\\n&quot; | sort | uniq -ci | tr [:alpha:] ' ' | sed s/[[:space:]]//g) # 上面的是对字符的处理 # tr &quot; &quot; &quot;\\n&quot;把空格换成换行 # sort 排序 # uniq -ci 去重,c是输出重复的个数,i是忽略大小写 # tr [:alpha:] ' '是把字符换成空格 # sed s/[[:space:]]//g 删除所有的空格 # 这个可能会有bug, 数字那个地方 count=0 for t in $test do # 把字符串变成数字 num=$((10#${t})) echo &quot;num = $num&quot; if [ $num -gt 1 ] ; then # 数字自增 count=$(($count+1)) fi done return $count}count $1echo $?# 我是写了个函数# 传入的参数是$1# 最后的echo $?是打印调用函数的返回值 我的解决方案还是有很大的缺陷过了测试是侥幸里面对字符串的处理还是不清楚 看看大佬的解决方案12345678910111213141516171819202122232425262728293031323334#! /bin/bashecho $1 | grep -o . | sort -f | uniq -id | wc -l# grep -o .# -o, --only-matching 只显示行中非空匹配部分# -o 后面的是正则表达式# sort -f :忽略大小写进行排序# uniq -id# 去重,-i 是忽略大小写,-d是打印重复的行,不重复的不显示# wc -l, 输出行数# 太强了# =====================================echo $1 | tr [A-Z] [a-z] | grep -o . | sort | uniq -d | wc -l# 这个大致都差不多# tr [A-Z] [a-z]是通过把大写都换成小写的,忽略大小写进行排序# =====================================echo $1 \\ | tr '[:upper:]' '[:lower:]' \\ | awk -F '' 'BEGIN{OFS=&quot;\\n&quot;} {$1=$1; print $0}' \\ | sort \\ | uniq -c \\ | awk '{if ($1&gt;=2) print $2}' \\ | wc -l# =====================================ls -al# why?????????????/# =====================================echo $@ | grep -o . | awk '{print toupper($0)}' | sort | uniq -idc | wc -l 学到的知识点 grep -o .sort -funiq -idctr ‘xxx’ ‘xxx’wc -l字符串转数字+shell 中数字相加 字符串转数字 >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#linux shell 字符串转数字#转载：https://blog.csdn.net/whish1994/article/details/78379659#原型： value=$((n#${key}Xm))#value:自定义变量得到运算的值#n:欲转成的进制数； 2进制就是2，10进制就是10#key:字符串变量#X：操作符；如+ - * / &amp;...#m:操作数#实例1：10进制字符32加上32a='32'value=$((10#${a}+32))#=================#!/bin/sh#本脚本测试shell脚本中整型变量自增 加1的几种方法#定义整型变量a=1echo $a#第一种整型变量自增方式a=$(($a+1))echo $a#第二种整型变量自增方式a=$[$a+1]echo $a#第三种整型变量自增方式a=`expr $a + 1`echo $a#第四种整型变量自增方式let a++echo $a#第五种整型变量自增方式let a+=1echo $a#第六种整型变量自增方式((a++))echo $a————————————————版权声明：本文为CSDN博主「yumushui」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/yumushui/article/details/53469845 希望能对你有所帮助(p_o)","link":"/2021/04/24/codewars/02_shell_%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E4%B8%AA%E6%95%B0.html/"},{"title":"03_cpp_电影票找钱问题","text":"题目链接内容介绍 123456789101112131415Description:The new &quot;Avengers&quot; movie has just been released! There are a lot of people at the cinema box office standing in a huge line. Each of them has a single 100, 50 or 25 dollar bill. An &quot;Avengers&quot; ticket costs 25 dollars.Vasya is currently working as a clerk. He wants to sell a ticket to every single person in this line.Can Vasya sell a ticket to every person and give change if he initially has no money and sells the tickets strictly in the order people queue?Return YES, if Vasya can sell a ticket to every person and give change with the bills he has at hand at that moment. Otherwise return NO.Examples:tickets({25, 25, 50}) // =&gt; YEStickets({25, 100}) // =&gt; NO. Vasya will not have enough money to give change to 100 dollarstickets({25, 25, 50, 50, 100}) // =&gt; NO. Vasya will not have the right bills to give 75 dollars of change (you can't make two bills of 25 from one of 50) 我的解题思路把钱分为三类:25,50,100分别创建容器,来一个钱压入相对应的容器中当压入 50 时,查看 25 的容器中是否还有钱,没有就返回”NO”当压入 100 时,找钱 75,分两种情况,50+25|25+25+25通过判断解决代码演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748std::string tickets(const std::vector&lt;int&gt; &amp;peopleInLine){ // your code here if (peopleInLine[0] != 25) return &quot;NO&quot;; std::vector&lt;int&gt; m25; std::vector&lt;int&gt; m50; std::vector&lt;int&gt; m100; for (auto i : peopleInLine) { std::cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; std::endl; switch (i) { case 25: m25.push_back(i); break; case 50: m50.push_back(i); if (m25.size() == 0) return &quot;NO&quot;; m25.pop_back(); break; case 100: { m100.push_back(i); if ((m50.size() &gt; 0 &amp;&amp; m25.size() &gt; 0) || (m25.size() &gt; 3)) { if (m50.size() == 0) { m25.pop_back(); m25.pop_back(); m25.pop_back(); } else { m50.pop_back(); m25.pop_back(); } } else return &quot;NO&quot;; break; } } } return &quot;YES&quot;;} 上面的代码还有可以优化的地方比如: 100 的容器根本就不用创建,因为不用 100 找零 大佬的解题代码12345678910std::string tickets(const std::vector&lt;int&gt; peopleInLine){ int count[2] = {0,0}; for(auto v: peopleInLine) { if(v == 25) count[0]++; if(v == 50) {count[1]++; count[0]--;} if(v == 100) {count[0]--; count[1]&gt;0? count[1]-- : count[0]-=2;} if(count[0]&lt;0||count[1]&lt;0) return &quot;NO&quot;; } return &quot;YES&quot;;} 分析:大佬是用数组将 25 和 50 的个数保存起来需要找零的时候就减一,收钱的时候就加一这样就更加的节省空间了当收钱 100 的时候,找零是必须要找一张 25 的所以可以提前找,后续判断 50 或 25 的够不够 希望能对你有所帮助(p_o)","link":"/2021/04/24/codewars/03_cpp_%E7%94%B5%E5%BD%B1%E7%A5%A8%E6%89%BE%E9%92%B1%E9%97%AE%E9%A2%98.html/"},{"title":"04_cpp_返回容器中的最小值","text":"题目链接内容介绍 12345678Given an array of integers your solution should find the smallest integer.For example: Given [34, 15, 88, 2] your solution will return 2 Given [34, -345, -1, 100] your solution will return -345You can assume, for the purpose of this kata, that the supplied array will not be empty. 我的代码这个题目还是很简单的 1234567891011int findSmallest(vector &lt;int&gt; list){ // Your Code is Here ... Hope you Enjoy int num = list[0]; for(auto &amp;i : list) { if(num &gt;= i) num = i; } return num;} 大佬的代码1234567#include &lt;algorithm&gt;#include &lt;vector&gt;int findSmallest(const std::vector&lt;int&gt;&amp; xs) { return *std::min_element(xs.cbegin(), xs.cend());}// 使用算法解决问题 这个题目的启发多使用 cpp 的语法,而不要纠结于 c 语言的cpp 的好多语法都很安全 希望能对你有所帮助(p_o)","link":"/2021/04/24/codewars/04_cpp_%E8%BF%94%E5%9B%9E%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC.html/"},{"title":"05_cpp_去除容器中最大值和最小值后其余值之和","text":"题目链接内容介绍 123456789101112131415161718Sum all the numbers of the array (in F# and Haskell you get a list) except the highest and the lowest element (the value, not the index!).(The highest/lowest element is respectively only one element at each edge, even if there are more than one with the same value!)Example:{ 6, 2, 1, 8, 10 } =&gt; 16{ 1, 1, 11, 2, 3 } =&gt; 6If array is empty, null or None, or if only 1 Element exists, return 0.Note:In C++ instead null an empty vector is used. In C there is no null. ;-)-- There's no null in Haskell, therefore Maybe [Int] is used. Nothing represents null.Have fun coding it and please don't forget to vote and rank this kata! :-)I have created other katas. Have a look if you like coding and challenges. 我的解题代码 12345678910111213141516171819202122#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int sum(vector&lt;int&gt; numbers){ if (numbers.size() &lt; 2) return 0; int min = *std::min_element(numbers.cbegin(), numbers.cend()); int max = *std::max_element(numbers.cbegin(), numbers.cend()); int add=0; for(auto &amp;i : numbers) add+=i; return add-min-max;}/** * 这里我使用了前面学的算法 * 轻松获得容器中的最大值和最小值 * 对容器内所有元素求和再减去最大值和最小值 * 注意: * 当容器为空,或者只有一个元素的时候,返回0*/ 希望能对你有所帮助(p_o)","link":"/2021/04/24/codewars/05_cpp_%E5%8E%BB%E9%99%A4%E5%AE%B9%E5%99%A8%E4%B8%AD%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC%E5%90%8E%E5%85%B6%E4%BD%99%E5%80%BC%E4%B9%8B%E5%92%8C.html/"},{"title":"06_cpp_返回容器中连续数字的最大值","text":"题目链接内容介绍 12345678The maximum sum subarray problem consists in finding the maximum sum of a contiguous subsequence in an array or list of integers:maxSequence({-2, 1, -3, 4, -1, 2, 1, -5, 4});//should be 6: {4, -1, 2, 1}Easy case is when the list is made up of only positive numbers and the maximum sum is the sum of the whole array. If the list is made up of only negative numbers, return 0 instead.Empty list is considered to have zero greatest sum. Note that the empty list or array is also a valid sublist/subarray. 题目的大致意思就是,给你一个容器,里面是 int 型变量写一个函数,返回一个最大值,这个最大值是容器里面连续片段求和的最大值 我的解题思路刚开始的时候,想法出错了,搞了一半写不出来了然后我就选择了最笨的方法,遍历所有的连续的容器片段之和然后返回我的最大值,虽然方法笨但是还能写出来我的代码片段 解题代码 >folded1234567891011121314151617181920212223242526272829303132#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int maxSequence(const vector&lt;int&gt; arr){ //... std::vector&lt;int&gt; result; int num = 0, max = 0, ni = 0, nj = 0; for (auto i : arr) { num = i; for (auto j : arr) { if (ni &lt; nj) { num = j + num; result.push_back(num); } nj++; } if(max &lt; *(max_element(result.cbegin(), result.cend()))) { max = *(max_element(result.cbegin(), result.cend())); } result.clear(); ni++; num = 0; nj = 0; } return max;} 我的代码还是有改进的地方这个函数传入的参数类型是const vector&lt;int&gt; &amp;arr带有 const 在刚开始我写的时候,用的是vector&lt;int&gt;::iterator i = arr.begin但是会报错,那时候没反应过来,该用了for(auto i : arr)但是临时变量就多了,而且二次循环的时候比较有问题,当我提交之后,看到了*max_element(result.cbegin(), result.cend())里面的cbegin()、cend()和begin()、end()有区别我去百度了一下,发现cbegin()和cend()是适用于vector&lt;int&gt;::const_iterator i = arr.begin();发现没有报错1.iterator,const_iterator 作用：遍历容器内的元素，并访问这些元素的值。iterator 可以改元素值,但 const_iterator 不可改。跟 C 的指针有点像。2.const_iterator 对象可以用于 const vector 或非 const vector,它自身的值可以改(可以指向其他元素),但不能改写其指向的元素值。3.cbegin()和 cend()是 C++11 新增的，它们返回一个 const 的迭代器，不能用于修改元素。原文链接又 get 到一个知识点下面的代码是我优化后的方案 优化方案1234567891011121314151617181920212223int maxSequence(const std::vector&lt;int&gt; arr){ //... std::vector&lt;int&gt; result; int num = 0, max = 0; for (std::vector&lt;int&gt;::const_iterator i = arr.cbegin(); i != arr.cend(); i++) { num = *i; for (std::vector&lt;int&gt;::const_iterator j = i + 1; j != arr.cend(); j++) { num = *j + num; result.push_back(num); } num = 0; if (max &lt; *std::max_element(result.cbegin(), result.cend())) { max = *std::max_element(result.cbegin(), result.cend()); } result.clear(); } std::cout &lt;&lt; &quot;max == &quot; &lt;&lt; max &lt;&lt; std::endl; return max;} 代码优化之后就不臃肿了运行的效率也提高了不少优化后的运行时间2720:优化前的运行时间2986[注释:是网站上显示的时间] 大佬的方案大佬的方案1123456789101112131415#include &lt;vector&gt;using namespace std;int maxSequence(const vector&lt;int&gt;&amp; arr){ int sum = 0, maxsum = 0; if (arr.size() == 0){return 0;} for (auto x: arr) { sum = max(sum+x,0); maxsum = max(maxsum,sum); } return maxsum;} 大佬的方案21234567891011121314151617#include &lt;vector&gt;using namespace std;int maxSequence(const vector&lt;int&gt;&amp; arr) { int localmax=0; int globalmax=0; for (int i = 0;i&lt;arr.size();i++) { localmax = localmax + arr[i]; if (localmax &gt; globalmax) globalmax = localmax; if (localmax &lt; 0) localmax = 0; } return globalmax;} 大佬的方案就是简洁学到的知识点 交替遍历数据 cbegin()和 cend() 求容器的最大值:*std::max_element(result.cbegin(), result.cend()); 希望能对你有所帮助(p_o)","link":"/2021/04/24/codewars/06_cpp_%E8%BF%94%E5%9B%9E%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%BF%9E%E7%BB%AD%E6%95%B0%E5%AD%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC.html/"},{"title":"07_cpp_重新排列数字返回尽可能大的数字","text":"题目链接内容介绍 12345678Your task is to make a function that can take any non-negative integer as an argument and return it with its digits in descending order. Essentially, rearrange the digits to create the highest possible number.Examples:Input: 42145 Output: 54421Input: 145263 Output: 654321Input: 123456789 Output: 987654321 我的解题思路 把给的数字拆分成单个数字放入到容器中 对容器排序 逆向迭代器输出得到最大值 返回最大值 代码如下 12345678910111213141516171819// 这个头文件提供了`uint64_t`这个数据类型#include &lt;cinttypes&gt;uint64_t descendingOrder(uint64_t a){ std::vector&lt;int&gt; v; uint64_t max = 0; for (size_t i = 0; a != 0; i++) { v.push_back(a % 10); a = a / 10; } sort(v.begin(), v.end()); for (std::vector&lt;int&gt;::reverse_iterator i = v.rbegin(); i != v.rend(); i++) { max = max * 10 + *i; } return max;} 大佬的解决方案大佬的解决方案112345678910111213141516171819#include &lt;cinttypes&gt;#include &lt;string&gt;#include &lt;algorithm&gt;uint64_t descendingOrder(uint64_t a){ std::string s = std::to_string(a); std::sort(s.rbegin(), s.rend()); return std::stoull(s);}/** * 这份代码很简洁 * 使用的方法是把数字直接通过std:to_string转换成string类型 * 然后使用std::sort进行排序 * 最后通过std::stoull进行输出返回 * 这个stoull是string头文件中的 * 就是把字符串转换成数字用的,还有其他的一些函数也是这样的 * 只是返回值(数字)的类型不一样*/ 大佬的解决方案212345678910111213141516171819202122232425#include &lt;cinttypes&gt;uint64_t descendingOrder(uint64_t a){ std::vector&lt;int&gt; c ; for(uint64_t b = a ; b &gt; 0 ; b /=10) c.push_back(b % 10); for(int i=0 ; i &lt; c.size() ; i++) for(int j=i; j &lt; c.size() ; j++) if(c[i] &lt; c[j]) std::swap(c[i],c[j]); a=0; for(int i=0; i &lt; c.size() ;i++) a = a*10 + c[i]; return a;}/** * 这份代码中 * 值的学习的是那个std::swap()函数 * 交换函数还是很常用的,这个要记住对于容器来说*/ 学到的知识点逆向迭代器的方法可以使用vector&lt;int&gt;::reverse_iterator的方法sort 排序是在&lt;algorithm&gt;头文件中的,要注意sort 排序的还可以自定义排序方式std::sort(v1, v2, func);通过编写 func 函数进行排序,排序规则是根据 func 函数进行的sort 排序之后,默认是从小到大的可以使用std::reverse()进行逆向再排序 希望能对你有所帮助(p_o)","link":"/2021/04/25/codewars/07_cpp_%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E5%AD%97%E8%BF%94%E5%9B%9E%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%A4%A7%E7%9A%84%E6%95%B0%E5%AD%97.html/"},{"title":"09_cpp_返回两个字符串中所有出现的字符组成的字符串","text":"题目链接内容介绍 123456789Take 2 strings s1 and s2 including only letters from ato z. Return a new sorted string, the longest possible, containing distinct letters - each taken only once - coming from s1 or s2.Examples:a = &quot;xyaabbbccccdefww&quot;b = &quot;xxxxyyyyabklmopq&quot;longest(a, b) -&gt; &quot;abcdefklmopqwxy&quot;a = &quot;abcdefghijklmnopqrstuvwxyz&quot;longest(a, a) -&gt; &quot;abcdefghijklmnopqrstuvwxyz&quot; 我的解题思路 创建一个数组int arr[128] 把出现的字符都添加到里面arr[char]++ 最后遍历 arr 数组,大于 1 的都是出现过的 然后就可以得到出现过字符的 ascii 码,返回即可 代码演示 12345678910111213141516171819202122232425262728293031#include &lt;string&gt;#include &lt;limits&gt;class TwoToOne{public: static std::string longest(const std::string &amp;s1, const std::string &amp;s2);};std::string TwoToOne::longest(const std::string &amp;s1, const std::string &amp;s2){ int arr[std::numeric_limits&lt;char&gt;::max()] = {0}; std::string str = &quot;&quot;; for(auto i : s1) { arr[i]++; } for(auto i : s2) { arr[i]++; } for (size_t i = 0; i &lt; std::numeric_limits&lt;char&gt;::max(); i++) { /* code */ if (arr[i] &gt; 0) { str += i; } } return str;} 大佬的解题方案大佬的解题方案1123456789101112131415161718192021222324#include &lt;set&gt;#include &lt;string&gt;class TwoToOne{public: static std::string longest(const std::string &amp;s1, const std::string &amp;s2) { std::set&lt;char&gt; se; se.insert(s1.begin(),s1.end()); se.insert(s2.begin(),s2.end()); return std::string(se.begin(),se.end()); }};/** * 这个解决方案是使用set容器 * 这个容器最大的特点就是是一个集合 * 但是里面的元素是唯一的 * 这样就确保了不会重复 * 好像这个最后是可以自动排序的, * 很棒的思路,不用考虑其他的内容 * 两次添加字符串即可解决字符重复的问题*/ 大佬的解决方案212345678910111213141516171819class TwoToOne{public: static std::string longest(const std::string &amp;s1, const std::string &amp;s2) { std::string concat = s1 + s2; std::sort(concat.begin(), concat.end()); auto end = std::unique(concat.begin(), concat.end()); return std::string(concat.begin(), end); }};/** * 这个的思路是先合并成一个字符串 * 然后排序该字符串 * 然后去重 * 也很不错,使用的是std::unique() * 这个函数是在算法头文件中&lt;algorithm&gt;*/ 学到的知识点 初识 set 容器 set 的插入 insert,可以插入范围 联想其他容器 vector 之类的也可以进行范围性插入 std::unique();去重函数 希望能对你有所帮助(p_o)","link":"/2021/04/25/codewars/09_cpp_%E8%BF%94%E5%9B%9E%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%87%BA%E7%8E%B0%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BB%84%E6%88%90%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.html/"},{"title":"08_cpp_银行汇率问题","text":"题目链接内容介绍 12345678910111213141516171819202122232425262728In a small town the population is p0 = 1000 at the beginning of a year. The population regularly increases by 2 percent per year and moreover 50 new inhabitants per year come to live in the town. How many years does the town need to see its population greater or equal to p = 1200 inhabitants?At the end of the first year there will be:1000 + 1000 * 0.02 + 50 =&gt; 1070 inhabitantsAt the end of the 2nd year there will be:1070 + 1070 * 0.02 + 50 =&gt; 1141 inhabitants (** number of inhabitants is an integer **)At the end of the 3rd year there will be:1141 + 1141 * 0.02 + 50 =&gt; 1213It will need 3 entire years.More generally given parameters:p0, percent, aug (inhabitants coming or leaving each year), p (population to surpass)the function nb_year should return n number of entire years needed to get a population greater or equal to p.aug is an integer, percent a positive or null floating number, p0 and p are positive integers (&gt; 0)Examples:nb_year(1500, 5, 100, 5000) -&gt; 15nb_year(1500000, 2.5, 10000, 2000000) -&gt; 10Note:Don't forget to convert the percent parameter as a percentage in the body of your function: if the parameter percent is 2 you have to convert it to 0.02. 我的解题思路循环解决代码演示 12345678910111213141516class Arge{ public: static int nbYear(int p0, double percent, int aug, int p);};int Arge::nbYear(int p0, double percent, int aug, int p){ int count = 0; while(p0 &gt;= p) { p0 = p0 + p0 * percent / 100 + aug; count++; } return count;} 希望能对你有所帮助(p_o)","link":"/2021/04/25/codewars/08_cpp_%E9%93%B6%E8%A1%8C%E6%B1%87%E7%8E%87%E9%97%AE%E9%A2%98.html/"},{"title":"13_shell_从1加到n并返回","text":"题目链接内容介绍 1234567891011SummationWrite a program that finds the summation of every number from 1 to num. The number will always be a positive integer greater than 0.For example:summation(2) -&gt; 31 + 2summation(8) -&gt; 361 + 2 + 3 + 4 + 5 + 6 + 7 + 8 本质上来说这个题还是很简单不过要注意的地方是数字的运算我的代码演示 12345678n=$1# your code herenum=0for((i=1;i&lt;=n;i++))do ((num+=i));doneecho $num 注意:数字的运算必须在(())可以直接运算不然是字符串的操作看看大佬的奇妙解题方式 大佬的解决方案1echo $(($1 * ($1 + 1) / 2)) get 到的知识点在 shell 中相关括号的使用 希望能对你有所帮助(p_o)","link":"/2021/04/26/codewars/13_shell_%E4%BB%8E1%E5%8A%A0%E5%88%B0n%E5%B9%B6%E8%BF%94%E5%9B%9E.html/"},{"title":"15_python_返回字符串中部分片段","text":"题目链接内容介绍 >folded12345678910111213141516171819You are going to be given a word. Your job is to return the middle character of the word. If the word's length is odd, return the middle character. If the word's length is even, return the middle 2 characters.#Examples:Kata.getMiddle(&quot;test&quot;) should return &quot;es&quot;Kata.getMiddle(&quot;testing&quot;) should return &quot;t&quot;Kata.getMiddle(&quot;middle&quot;) should return &quot;dd&quot;Kata.getMiddle(&quot;A&quot;) should return &quot;A&quot;#InputA word (string) of length 0 &lt; str &lt; 1000 (In javascript you may get slightly more than 1000 in some test cases due to an error in the test cases). You do not need to test for this. This is only here to tell you that you do not need to worry about your solution timing out.#OutputThe middle character(s) of the word represented as a string. 这个题的意思是如果给的字符串有偶数个字符,则返回中间那俩如果给的字符串有奇数个字符,则返回中间那个代码演示 123456def get_middle(s): l = len(s) if l % 2 == 0: return s[int(l/2)-1:int(l/2)+1:1] else: return s[int(l/2)] 我使用的是切片获取中间的字符大佬的解决方案 12def get_middle(s): return s[(len(s)-1)/2:len(s)/2+1] 希望能对你有所帮助(p_o)","link":"/2021/04/27/codewars/15_python_%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E9%83%A8%E5%88%86%E7%89%87%E6%AE%B5.html/"},{"title":"16_shell_计算统计数据并返回","text":"题目链接内容介绍 内容介绍 >folded12345678910111213141516171819202122232425262728A bookseller has lots of books classified in 26 categories labeled A, B, ... Z. Each book has a code c of 3, 4, 5 or more characters. The 1st character of a code is a capital letter which defines the book category.In the bookseller's stocklist each code c is followed by a space and by a positive integer n (int n &gt;= 0) which indicates the quantity of books of this code in stock.For example an extract of a stocklist could be:L = {&quot;ABART 20&quot;, &quot;CDXEF 50&quot;, &quot;BKWRK 25&quot;, &quot;BTSQZ 89&quot;, &quot;DRTYM 60&quot;}.orL = [&quot;ABART 20&quot;, &quot;CDXEF 50&quot;, &quot;BKWRK 25&quot;, &quot;BTSQZ 89&quot;, &quot;DRTYM 60&quot;] or ....You will be given a stocklist (e.g. : L) and a list of categories in capital letters e.g :M = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;W&quot;}orM = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;W&quot;] or ...and your task is to find all the books of L with codes belonging to each category of M and to sum their quantity according to each category.For the lists L and M of example you have to return the string (in Haskell/Clojure/Racket a list of pairs):(A : 20) - (B : 114) - (C : 50) - (W : 0)where A, B, C, W are the categories, 20 is the sum of the unique book of category A, 114 the sum corresponding to &quot;BKWRK&quot; and &quot;BTSQZ&quot;, 50 corresponding to &quot;CDXEF&quot; and 0 to category 'W' since there are no code beginning with W.If L or M are empty return string is &quot;&quot; (Clojure and Racket should return an empty array/list instead).Note:In the result codes and their values are in the same order as in M. 我的解题思路 没啥思路 不停的拆解字符串 变换字符串,提取字符串中的关键数据 组装关键数据,并返回 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/bin/bashstock_list () { # your code declare -A m #s1=$(echo $1 | awk -F, '{for(i=1;i&lt;=NF;i++){print $i}}') s2=$(echo $2 | awk -F, '{for(i=1;i&lt;=NF;i++){print $i}}') for i in $s2 do m[$i]=0 done row=$(echo $1 | tr ' ' '-' | tr ',' ' ') for i in $row do head=$(echo $i | grep -o ^.) num=$(echo $i | grep -o [0-9]*) #echo &quot;head=$head num=$num&quot; if [ ${m[$head]} ] ; then #echo &quot;$head&quot; test=$(echo $num | grep -o &quot;[1-9][0-9]*&quot;) #echo &quot;test=$test&quot; m[$head]=$(($(($test)) + $((${m[$head]})))) fi done # 遍历map,根据key查找value for key in $s2; do #echo &quot;key:$key, val:${m[$key]}&quot; str=&quot;$str - &quot;&quot;($key : ${m[$key]})&quot; #echo $str done if [ -z $row ] ; then echo &quot;&quot; else echo $str | grep -o &quot;(.*$&quot; fi #for((i=0;i&lt;$(echo $s1 | wc -l); i++)) #do # echo &quot;i=$i&quot; # head=$(echo $1 | awk -F, '{print $i}' | grep -o ^.) # num=$(echo $1 | awk -F, '{print $i}' | grep -o [0-9]*) # echo &quot;head=$head, num=$num&quot; # #m[$i]=$(echo $s1 | grep -o [0-9]*) #done}stock_list &quot;$1&quot; &quot;$2&quot; get 到的知识点 grep 的练习使用 awk 的练习使用 使用 shell 中的 map(这个是看网上的) map 对我来说还是有点难的,初次接触 我不会解决这个问题了,就去网上找 shell 的数据结构 发现这个 map 符合我的预期就使用了 这个以后还是要练习练习的 大佬的解决方案希望能对你有所帮助(p_o)","link":"/2021/04/28/codewars/16_shell_%E8%AE%A1%E7%AE%97%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%BF%94%E5%9B%9E.html/"},{"title":"14_python_字符串的逆序返回","text":"题目链接内容介绍 123Complete the solution so that it reverses the string passed into it.'world' =&gt; 'dlrow' 这个题目是给定一个字符串返回这个字符串的逆序我的方法是使用切片代码如下 123def solution(string): return string[::-1] pass get 到的知识点切片技术切片里面有三个变量 第一个变量 start_index 是起始索引地址 第二个变量 end_index 是结束索引地址 第三个变量 step 是步数,就是间隔是多少 更多内容请查看详细讲解 希望能对你有所帮助(p_o)","link":"/2021/04/27/codewars/14_python_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%80%86%E5%BA%8F%E8%BF%94%E5%9B%9E.html/"},{"title":"01_初步使用docker","text":"摘要第一步:安装 Docker终端执行curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun注意:在我的 debian 的使用中,每次都需要sudo为了不节省可以使用以下办法解决sudo usermod -aG docker ${USER}sudo service docker restart重启操作系统即可 第二步:常规操作 search pull images run 容器的停止启动和重启等 链接容器 删除容器 删除镜像 常规操作搜索镜像搜索镜像 >folded12345678910111213141516171819202122232425262728zpf@debian:~/Test/docker$ docker search ubuntuNAME DESCRIPTION STARS OFFICIAL AUTOMATEDubuntu Ubuntu is a Debian-based Linux operating sys… 12133 [OK]dorowu/ubuntu-desktop-lxde-vnc Docker image to provide HTML5 VNC interface … 523 [OK]websphere-liberty WebSphere Liberty multi-architecture images … 267 [OK]rastasheep/ubuntu-sshd Dockerized SSH service, built on top of offi… 249 [OK]consol/ubuntu-xfce-vnc Ubuntu container with &quot;headless&quot; VNC session… 236 [OK]ubuntu-upstart Upstart is an event-based replacement for th… 110 [OK]1and1internet/ubuntu-16-nginx-php-phpmyadmin-mysql-5 ubuntu-16-nginx-php-phpmyadmin-mysql-5 50 [OK]ubuntu-debootstrap debootstrap --variant=minbase --components=m… 44 [OK]open-liberty Open Liberty multi-architecture images based… 43 [OK]nuagebec/ubuntu Simple always updated Ubuntu docker images w… 24 [OK]i386/ubuntu Ubuntu is a Debian-based Linux operating sys… 24solita/ubuntu-systemd Ubuntu + systemd 24 [OK]1and1internet/ubuntu-16-apache-php-5.6 ubuntu-16-apache-php-5.6 14 [OK]1and1internet/ubuntu-16-apache-php-7.0 ubuntu-16-apache-php-7.0 13 [OK]1and1internet/ubuntu-16-nginx-php-phpmyadmin-mariadb-10 ubuntu-16-nginx-php-phpmyadmin-mariadb-10 11 [OK]1and1internet/ubuntu-16-nginx-php-5.6-wordpress-4 ubuntu-16-nginx-php-5.6-wordpress-4 9 [OK]1and1internet/ubuntu-16-nginx-php-5.6 ubuntu-16-nginx-php-5.6 8 [OK]1and1internet/ubuntu-16-apache-php-7.1 ubuntu-16-apache-php-7.1 6 [OK]1and1internet/ubuntu-16-nginx-php-7.0 ubuntu-16-nginx-php-7.0 4 [OK]pivotaldata/ubuntu A quick freshening-up of the base Ubuntu doc… 4pivotaldata/ubuntu16.04-build Ubuntu 16.04 image for GPDB compilation 2pivotaldata/ubuntu-gpdb-dev Ubuntu images for GPDB development 11and1internet/ubuntu-16-php-7.1 ubuntu-16-php-7.1 1 [OK]smartentry/ubuntu ubuntu with smartentry 1 [OK]1and1internet/ubuntu-16-rspec ubuntu-16-rspec 0 [OK] docker 拉取镜像拉取镜像 >folded12345678zpf@debian:~/Test/docker$ docker pull ubuntu:latestlatest: Pulling from library/ubuntua70xxxxxxx98: Pull completec43xxxxxxxf8: Pull complete10exxxxxxxc0: Pull completeDigest: sha256:3c9c713e097xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx9d695fb8039aa1fStatus: Downloaded newer image for ubuntu:latestdocker.io/library/ubuntu:latest docker 列出镜像列表镜像列表1234567zpf@debian:~/Test/docker$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEubuntu latest 26bxxxxxxx2b 2 weeks ago 72.9MBzpf@debian:~/Test/docker$ docker images -aREPOSITORY TAG IMAGE ID CREATED SIZEubuntu latest 26bxxxxxxx2b 2 weeks ago 72.9MB# -a 参数可以列出一些其他的镜像 docker 创建容器docker创建容器1234567891011zpf@debian:~/Test/docker$ docker run -i -t --name hello ubuntu /bin/bashroot@7c5xxxxxxx01:/# lsbin boot dev etc home lib lib32 lib64 libx32 media mnt opt proc root run sbin srv sys tmp usr var## 命令的格式为 docker run &lt;选项&gt; &lt;镜像名称&gt; &lt;要运行的文件&gt;# 上面的意思是把ubuntu创建为名为hello的容器后# 运行ubuntu镜像中的/bin/bash## 使用-i(interactive)、-t(Pseudo-tty)选项可以在运行的Bash Shell中进行输入和输出# 使用--name选项可以指定容器的名称,若不指定,docker会自动生成名称并进行指定# 使用exit则退出容器,回到主机的shell终端中 docker 查看容器列表docker查看容器列表123456789zpf@debian:~/Test/docker$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESzpf@debian:~/Test/docker$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES7c574e977a01 ubuntu &quot;/bin/bash&quot; 5 minutes ago Exited (0) 7 seconds ago hello## 添加-a参数可以列出所有的容器# 默认的ps是列出所有活动的容器# docker 启动容器docker启动/重启/停止容器1234567891011121314151617181920212223242526zpf@debian:~/Test/docker$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES7c574e977a01 ubuntu &quot;/bin/bash&quot; 7 minutes ago Up 25 seconds hellozpf@debian:~/Test/docker$ docker restart hellohellozpf@debian:~/Test/docker$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES7c574e977a01 ubuntu &quot;/bin/bash&quot; 7 minutes ago Up 2 seconds hellozpf@debian:~/Test/docker$ docker stop hellohellozpf@debian:~/Test/docker$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESzpf@debian:~/Test/docker$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES7c574e977a01 ubuntu &quot;/bin/bash&quot; 7 minutes ago Exited (0) 4 seconds ago hellozpf@debian:~/Test/docker$ docker start hellohellozpf@debian:~/Test/docker$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES7c574e977a01 ubuntu &quot;/bin/bash&quot; 8 minutes ago Up 2 seconds hellozpf@debian:~/Test/docker$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES7c574e977a01 ubuntu &quot;/bin/bash&quot; 9 minutes ago Up 3 seconds hellozpf@debian:~/Test/docker$ docker attach helloroot@7c574e977a01:/# lsbin boot dev etc home lib lib32 lib64 libx32 media mnt opt proc root run sbin srv sys tmp usr var docker 删除容器和镜像docker删除容器和镜像123456789101112131415161718192021222324252627282930# 删除容器zpf@debian:~/Test/docker$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESzpf@debian:~/Test/docker$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES7c574e977a01 ubuntu &quot;/bin/bash&quot; 10 minutes ago Exited (0) 13 seconds ago hellozpf@debian:~/Test/docker$ docker rm hellohellozpf@debian:~/Test/docker$ docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESzpf@debian:~/Test/docker$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES# 删除镜像zpf@debian:~/Test/docker$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEubuntu latest 26b77e58432b 2 weeks ago 72.9MBzpf@debian:~/Test/docker$ docker images -aREPOSITORY TAG IMAGE ID CREATED SIZEubuntu latest 26b77e58432b 2 weeks ago 72.9MBzpf@debian:~/Test/docker$ docker rmi ubuntu:latestUntagged: ubuntu:latestUntagged: ubuntu@sha256:3c9c713e95aa06xxxxxxxxxxd695fb8039aa1fDeleted: sha256:26b77e58ab82576a0xxxxxxxx24f5cf3dac146d6Deleted: sha256:9de65d1ec1e4c8xxxxxxxxxfbd7d098d6234f359Deleted: sha256:e0f8e3axxxxxxxxxxxf17c2bf9d8e5e248cfe5b0Deleted: sha256:0e64bafdc7ee8xxxxxxxxxxxxeeb569f4a83db56d505zpf@debian:~/Test/docker$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEzpf@debian:~/Test/docker$ docker images -aREPOSITORY TAG IMAGE ID CREATED SIZE 希望能对你有所帮助(p_o)","link":"/2021/04/23/docker/01_%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8docker.html/"},{"title":"docker学习之路","text":"摘要学习 docker,并通过博客的方式记录下来参考的书籍是Docker 基础与实战 书名: Docker 基础与实战 ISBN: 978-7-115-41962-0 封面 目录第 01 章: Docker第 02 章: 安装 Docker第 03 章: 使用 Docker第 04 章: 创建 Docker 镜像第 05 章: 查看 Docker第 06 章: 灵活使用 Docker第 07 章: 详细了解 Dockerfile第 08 章: 使用 Docker 部署应用程序第 09 章: Docker 监控第 10 章: 在 Amazon Web Services 中使用 Docker第 11 章: 在 Google Cloud Platform 中使用 Docker第 12 章: 使用 Docker Hub第 13 章: 使用 Docker Remote API第 14 章: 使用 CentOS第 15 章: 使用 Docker 搭建 WordPress 博客第 16 章: 使用 Docker 构建 Ruby on Rails 应用第 17 章: 使用 Docker 构建 Django 应用第 18 章: Docker 应用案例第 19 章: Docker 命令与选项列表 希望能对你有所帮助(p_o)","link":"/2021/04/22/docker/docker%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF.html/"},{"title":"10_cpp_字符串的简单加密和解密","text":"题目链接内容介绍 12345678910111213141516171819202122232425For building the encrypted string:Take every 2nd char from the string, then the other chars, that are not every 2nd char, and concat them as new String.Do this n times!Examples:&quot;This is a test!&quot;, 1 -&gt; &quot;hsi etTi sats!&quot;&quot;This is a test!&quot;, 2 -&gt; &quot;hsi etTi sats!&quot; -&gt; &quot;s eT ashi tist!&quot;Write two methods:std::string encrypt(std::string text, int n)std::string decrypt(std::string encryptedText, int n)For both methods:If the input-string is null or empty return exactly this value!If n is &lt;= 0 then return the input text.This kata is part of the Simple Encryption Series:Simple Encryption #1 - Alternating SplitSimple Encryption #2 - Index-DifferenceSimple Encryption #3 - Turn The Bits AroundSimple Encryption #4 - QwertyHave fun coding it and please don't forget to vote and rank this kata! :-) 经分析这个加密和解密是简单越过一个单词后进行组装的多次循环即可加密再加密的时候要注意原字符串的长度是奇数还是偶数不然会导致加密的时候出错解密的时候,忘了解题代码如下 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;string&gt;std::string encrypt(std::string text, int n){ if (n &lt;= 0 || text.size() == 0) return text; std::string str = &quot;&quot;; int length = (text.size() % 2 == 0) ? text.size() + 1 : text.size(); for (int i = 0; i &lt; n; i++) { /* code */ for (int j = 0; j &lt; text.size(); j++) { str += text[(2 * (j + 1) - 1) % length]; } text = str; str = &quot;&quot;; } return text;}std::string decrypt(std::string encryptedText, int n){ if (n &lt;= 0 || encryptedText.size() == 0) return encryptedText; std::string str = &quot;&quot;; int length = encryptedText.size(); for (int i = 0; i &lt; n; i++) { /* code */ for (int j = 0; j &lt; length; j++) { /* code */ str += encryptedText[(j % 2 == 0) ? (j / 2) + (length / 2) : (j - 1) / 2]; } encryptedText = str; str = &quot;&quot;; } return encryptedText;} 大佬的解决方案大佬的解决方案12345678910111213141516171819202122232425262728template &lt;bool forward&gt;inline static std::string transform(std::string text) { int n = text.length(), k = 0; std::string s(n, ' '); for (int p = 1; p &gt;= 0; --p) for (int j = p; j &lt; n; j += 2) if (forward) s[k++] = text[j]; else s[j] = text[k++]; return s;}std::string encrypt(std::string text, int n) { for (int i = 0; i &lt; n; ++i) text = transform&lt;true&gt;(text); return text;}std::string decrypt(std::string text, int n) { for (int i = 0; i &lt; n; ++i) text = transform&lt;false&gt;(text); return text;}/** * 太强了 * 这个使用模板进行操作 * 节省了内存空间 * 也简单直白 * 模板中的双层循环 * 就是分别操作字符串中的奇数位和偶数位*/ 大佬的解决方案中还有就是常见的递归我本来也想使用递归的,分析的时候有难度就使用了 for 循环进行解决,使用 for 循环更容易的了解运行过程学到的知识点 要仔细分析运行过程 初始化 string 字符串的方式 std::string(n, ‘ ‘);创建长度为 n 的字符串,里面的值为空格 希望能对你有所帮助(p_o)","link":"/2021/04/25/codewars/10_cpp_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%AE%80%E5%8D%95%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86.html/"},{"title":"12_cpp_返回容器中与其他数不同那个数","text":"题目链接内容介绍 12345678910111213141516You are given an array (which will have a length of at least 3, but could be very large) containing integers. The array is either entirely comprised of odd integers or entirely comprised of even integers except for a single integer N. Write a method that takes the array as an argument and returns this &quot;outlier&quot; N.Examples[2, 4, 0, 100, 4, 11, 2602, 36]Should return: 11 (the only odd number)[160, 3, 1719, 19, 11, 13, -21]Should return: 160 (the only even number)/** * 大致的意思就是 * 给你一个容器, * 里面全是数字,容器大小最小为3个 * 里面只有一个奇数或偶数 * 请找出这个奇数或偶数并返回*/ 我的解题思路 该开始是打算用a[num%2]++得到奇数和偶数的个数 然后遍历容器中元素当比对上那个要求的数时就返回 后来不想循环两次就放弃了 然后打算是用 map 来解决这个问题 map 是一种映射关系,在 python 中就是字典(键值对) 所以这样就尤为的方便 我创建的是std::map&lt;bool, int&gt; m 通过上面的奇数和偶数个数差,再通过 map 的一个 find 函数查找 bool 类型 即可确定那个不一样的数 我的解题代码 12345678910111213141516#include &lt;vector&gt;#include &lt;map&gt;int FindOutlier(std::vector&lt;int&gt; arr){ int result = 0; std::map&lt;bool, int&gt; m; int a[2] = {0, 0}; for (auto i : arr) { m.insert(std::pair&lt;bool, int&gt;{i % 2, i}); a[i % 2]++; } result = (a[0] &lt; a[1]) ? m.find(false)-&gt;second : m.find(true)-&gt;second; return result;} 大佬的解决方案大佬的解决方案112345678910111213int FindOutlier(std::vector&lt;int&gt; arr){ int even; int odd; int evenCount = 0; int oddCount = 0; for (auto a : arr) a % 2 == 0 ? (evenCount++, even = a) : (oddCount++, odd = a); return evenCount &lt; oddCount ? even : odd;} 大佬的解决方案212345678910#include &lt;algorithm&gt;int FindOutlier(std::vector&lt;int&gt; arr){ bool lsb; if((lsb = arr[0]&amp;1) == (arr[1]&amp;1)) return *std::find_if(arr.begin()+2, arr.end(), [&amp;](const int&amp; i){ return (i&amp;1) != lsb; }); else return (lsb == (arr[2]&amp;1)) ? arr[1] : arr[0];} get 到的知识点 map 的初步使用 创建 map 键值对std::map&lt;bool,int&gt; m map 插入一个键值对m.insert(pair&lt;bool,int&gt;(false, 10)) map 的查找操作m.find(false)(注意:这里只是找到了) map 找到后访问第一个元素m.find(false)-&gt;first,第二个是m.find(false)-&gt;second first 是键(Key),second 是值(Value) 出大问题了………… TMD 这个 map 有问题,我忘了,key 只能有一个 还有要是测试的数据中有重复的数字的话,那反过来创建的&lt;int,bool&gt;也不行 但神奇的是我的代码通过了,好吧,在这里注意下 总之我的代码太烂了,但是过了,不管了,map 是个坑 是个大坑,在写博客的时候我去运行我修改后的 map 代码 真 TM 迷一样的数据结构,太 TM 蒙蔽了 以后好好学学这个 map 吧,键值对还是很有用的 上面的 map 我搞懂为啥我的那个测试通过了 准确的说,我那个代码不算是错误的 确实能实现那个功能 但是 map 里面只有两个键值对 一个是&lt;true, num1&gt; 一个是&lt;false, num2&gt; 当里面有多个 true 的时候,在把数据添加到 map 时 会覆盖里面原来的 true 的值,虽然覆盖了 但是我们要找的那个是 false,所以返回的内容还是我们要找的那个数据 希望能对你有所帮助(p_o)","link":"/2021/04/25/codewars/12_cpp_%E8%BF%94%E5%9B%9E%E5%AE%B9%E5%99%A8%E4%B8%AD%E4%B8%8E%E5%85%B6%E4%BB%96%E6%95%B0%E4%B8%8D%E5%90%8C%E9%82%A3%E4%B8%AA%E6%95%B0.html/"},{"title":"11_cpp_判断给定的字符串括号是不是匹配的","text":"题目链接内容介绍 123456789101112131415Write a function that takes a string of braces, and determines if the order of the braces is valid. It should return true if the string is valid, and false if it's invalid.This Kata is similar to the Valid Parentheses Kata, but introduces new characters: brackets [], and curly braces {}. Thanks to @arnedag for the idea!All input strings will be nonempty, and will only consist of parentheses, brackets and curly braces: ()[]{}.What is considered Valid?A string of braces is considered valid if all braces are matched with the correct brace.Examples&quot;(){}[]&quot; =&gt; True&quot;([{}])&quot; =&gt; True&quot;(}&quot; =&gt; False&quot;[(])&quot; =&gt; False&quot;[({})](]&quot; =&gt; False 我的解题思路刚开始是考虑到前段时间学到的栈了使用&lt;stack&gt;头文件去使用栈解决在我的 vscode 上是成功的解决了但是在 codewars 网站上却出现了错误还是内存错误,我在评论区看到和我一样错误的了但是没给答案,好像是用 gdb 调试发现有问题的(我不会)然后去百度,后来发现了一种不错的方法,就是字符串替换,把成对的()``{}``[]换成''这样最后换完之后如果字符串是空的,就返回 true,如果不是空的,就返回 false这样就解救这个问题了我的代码演示 1234567891011121314151617181920212223242526272829int valid_braces(std::string braces){ // valid or not valid? if (braces.size() % 2 == 0) { while (true) { /* code */ bool b1 = braces.find(&quot;{}&quot;) &lt; braces.size() / 2, b2 = braces.find(&quot;()&quot;) &lt; braces.size() / 2, b3 = braces.find(&quot;[]&quot;) &lt; braces.size() / 2; if (b1) braces = braces.replace(braces.find(&quot;{}&quot;), 2, &quot;&quot;); if (b2) braces = braces.replace(braces.find(&quot;()&quot;), 2, &quot;&quot;); if (b3) braces = braces.replace(braces.find(&quot;[]&quot;), 2, &quot;&quot;); std::cout &lt;&lt; braces &lt;&lt; std::endl; if (braces.empty()) return true; if (!b1 &amp;&amp; !b2 &amp;&amp; !b3) return false; } } else { return false; }} 大佬的解题思路大佬的解题思路1123456789101112131415161718192021222324252627bool valid_braces(std::string braces){ std::vector&lt;char&gt; stack; for (char tok : braces) { switch(tok) { case '(': stack.push_back(')'); break; case '[': stack.push_back(']'); break; case '{': stack.push_back('}'); break; case '}': case ']': case ')': if (stack.empty() || stack.back() != tok) return false; stack.pop_back(); } } return stack.empty();}/** * 这个使用的是容器,我也用了 * 但是还是报了内存错误*/ 大佬的解决思路2123456789101112#include &lt;regex&gt;bool valid_braces(std::string s) { std::regex r (&quot;\\\\(\\\\)|\\\\[\\\\]|\\\\{\\\\}&quot;); while (std::regex_search(s, r)) s = std::regex_replace(s, r, &quot;&quot;); return s.length() == 0;}/** * 使用正则表达式解决问题 * nice * 把匹配到的替换成空即可*/ 启发:在其他人的解决方案中我也发现了 stack 的使用,但是他们都通过了测试很奇怪,但是他们的也确实找不出错误,可能是我的在某些地方有问题吧get 到的知识点 了解 string 的替换 了解 string 的 find 查找函数 上面那两个还要继续学习,重载很多 初识 map 初识 regex string的发现函数 >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566s.find(s1) //查找s中第一次出现s1的位置，并返回（包括0）s.rfind(s1) //查找s中最后次出现s1的位置，并返回（包括0）s.find_first_of(s1) //查找在s1中任意一个字符在s中第一次出现的位置，并返回（包括0）s.find_last_of(s1) //查找在s1中任意一个字符在s中最后一次出现的位置，并返回（包括0）s.fin_first_not_of(s1) //查找s中第一个不属于s1中的字符的位置，并返回（包括0）s.fin_last_not_of(s1) //查找s中最后一个不属于s1中的字符的位置，并返回（包括0）// 官方网站上的内容;https://zh.cppreference.com/w/cpp/header/stringtemplate&lt;class T&gt; constexpr size_type find(const T&amp; t, size_type pos = 0) const noexcept(/* 见描述 */);constexpr size_type find(const basic_string&amp; str, size_type pos = 0) const noexcept;constexpr size_type find(const CharT* s, size_type pos, size_type n) const;constexpr size_type find(const CharT* s, size_type pos = 0) const;constexpr size_type find(CharT c, size_type pos = 0) const noexcept;template&lt;class T&gt; constexpr size_type rfind(const T&amp; t, size_type pos = npos) const noexcept(/* 见描述 */);constexpr size_type rfind(const basic_string&amp; str, size_type pos = npos) const noexcept;constexpr size_type rfind(const CharT* s, size_type pos, size_type n) const;constexpr size_type rfind(const CharT* s, size_type pos = npos) const;constexpr size_type rfind(CharT c, size_type pos = npos) const noexcept;template&lt;class T&gt; constexpr size_type find_first_of(const T&amp; t, size_type pos = 0) const noexcept(/* 见描述 */);constexpr size_type find_first_of(const basic_string&amp; str, size_type pos = 0) const noexcept;constexpr size_type find_first_of(const CharT* s, size_type pos, size_type n) const;constexpr size_type find_first_of(const CharT* s, size_type pos = 0) const;constexpr size_type find_first_of(CharT c, size_type pos = 0) const noexcept;template&lt;class T&gt; constexpr size_type find_last_of(const T&amp; t, size_type pos = npos) const noexcept(/* 见描述 */);constexpr size_type find_last_of(const basic_string&amp; str, size_type pos = npos) const noexcept;constexpr size_type find_last_of(const CharT* s, size_type pos, size_type n) const;constexpr size_type find_last_of(const CharT* s, size_type pos = npos) const;constexpr size_type find_last_of(CharT c, size_type pos = npos) const noexcept;template&lt;class T&gt; constexpr size_type find_first_not_of(const T&amp; t, size_type pos = 0) const noexcept(/* 见描述 */);constexpr size_type find_first_not_of(const basic_string&amp; str, size_type pos = 0) const noexcept;constexpr size_type find_first_not_of(const CharT* s, size_type pos, size_type n) const;constexpr size_type find_first_not_of(const CharT* s, size_type pos = 0) const;constexpr size_type find_first_not_of(CharT c, size_type pos = 0) const noexcept;template&lt;class T&gt; constexpr size_type find_last_not_of(const T&amp; t, size_type pos = npos) const noexcept(/* 见描述 */);constexpr size_type find_last_not_of(const basic_string&amp; str, size_type pos = npos) const noexcept;constexpr size_type find_last_not_of(const CharT* s, size_type pos, size_type n) const;constexpr size_type find_last_not_of(const CharT* s, size_type pos = npos) const;constexpr size_type find_last_not_of(CharT c, size_type pos = npos) const noexcept; string的替换 >folded123456789101112131415161718192021222324constexpr basic_string&amp; replace(size_type pos1, size_type n1, const basic_string&amp; str);constexpr basic_string&amp; replace(size_type pos1, size_type n1, const basic_string&amp; str, size_type pos2, size_type n2 = npos);template&lt;class T&gt; constexpr basic_string&amp; replace(size_type pos1, size_type n1, const T&amp; t);template&lt;class T&gt; constexpr basic_string&amp; replace(size_type pos1, size_type n1, const T&amp; t, size_type pos2, size_type n2 = npos);constexpr basic_string&amp; replace(size_type pos, size_type n1, const CharT* s, size_type n2);constexpr basic_string&amp; replace(size_type pos, size_type n1, const CharT* s);constexpr basic_string&amp; replace(size_type pos, size_type n1, size_type n2, CharT c);constexpr basic_string&amp; replace(const_iterator i1, const_iterator i2, const basic_string&amp; str);template&lt;class T&gt; constexpr basic_string&amp; replace(const_iterator i1, const_iterator i2, const T&amp; t);constexpr basic_string&amp; replace(const_iterator i1, const_iterator i2, const CharT* s, size_type n);constexpr basic_string&amp; replace(const_iterator i1, const_iterator i2, const CharT* s);constexpr basic_string&amp; replace(const_iterator i1, const_iterator i2, size_type n, CharT c);template&lt;class InputIt&gt; constexpr basic_string&amp; replace(const_iterator i1, const_iterator i2, InputIt j1, InputIt j2);constexpr basic_string&amp; replace(const_iterator, const_iterator, initializer_list&lt;CharT&gt;); 希望能对你有所帮助(p_o)","link":"/2021/04/25/codewars/11_cpp_%E5%88%A4%E6%96%AD%E7%BB%99%E5%AE%9A%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%AC%E5%8F%B7%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8C%B9%E9%85%8D%E7%9A%84.html/"},{"title":"Hexo+Github Pages搭建个人博客","text":"Hexo+Github个人博客 摘要搭建个人博客借助Hexo和Github完成操作本人环境相关信息: 使用Kubuntu 20.04.2 LTS系统node版本 v12.18.0npm版本 6.14.4hexo版本 5.4.0hexo-cli版本 4.2.0 参考链接: Hexo官网Amazing主题Amazing主题参考Icarus主题(Amazing基于Icarus改造) 简述 >folded1234 我处于猎奇心理,在寒假打算搭建一个个人博客,在寒假最后几天,最终确定了我使用Hexo+Github来搭建属于我个人的博客.初次选用的主题是Icarus,由于初次了解这些东西,什么也不懂,不断的通过百度和其他网友的搭建过程了解了搭建过程.后遇到了Amazing主题, 博主removeif的网站有着对该主题的详细解释和操作,另外这个主题我也是十分的喜欢,就选中了这个主题.在此十分的感谢博主removeif 详细搭建过程 操作系统: 选择了KUbuntu来做为我的系统环境 也是为了更加的熟悉Linux 选择理由 ubuntu装了两次都崩溃了(装到u盘中) debian装进去之后打不开图形化界面(显卡驱动也有些问题) 其他Linux系统不太熟 kde很好看nice npm安装 不晓得为啥使用包管理apt安装的版本低而且有些问题 去官方下载源代码(点击下载v12.18.0)编译 解压出源代码编译(不需要管理员权限) ./configure make (过程十分漫长) make install make clean npm安装hexo-cli npm -g install hexo-cli 有时候会出现npm没有全局权限的报错(npm安装全局权限报错 Error: EACCES: permission denied) 解决办法 1.创建一个全局安装目录(以后全局安装的包都在这)mkdir ~/.npm-global 2.配置npm使用新的目录路径npm config set prefix '~/.npm-global' 3.添加系统变量export PATH=~/.npm-global/bin:$PATH只能当前使用,永久使用请手动添加PATH=&quot;~/.npm-global/bin:$PATH&quot;到~/.profile中 4.更新系统变量source ~/.profile 本地搭建并预览 这个搭建的博客只能本地预览 使用的主题是默认主题 更换hexo主题 更换主题之后要修改部分配置以适合自己 配置主题细节 每次更新主题之后请预览一下,防止出错不知道咋回事 配置hexo 配置完成之后一定要预览查看有没有出现问题 初次配置的时候推荐使用博主的配置 Github 注册Github和创建仓库就不说了,网上很多教程 部署到github: hexo d 过一会应该就可以访问&lt;username&gt;.github.io看到你的博客了 后续 部署到github还有很多可以做的:比如利用分支来保存hexo信息 hexo中还有很多有趣的地方可以开发 amazing主题中还有许多强大的功能 目前我很多东西还不晓得咋搞,先放着吧 配置hexo,多看看官网 配置hexo主题.多看看博主的帖子和个人博客 Hexo框架(一)：使用Hexo快速搭建个人博客 本地搭建并预览 123456789101112131415161718$ hexo init Blog$ cd Blog# 文件目录结构:&lt;&lt;!.├── _config.yml├── package.json├── scaffolds├── source│ ├── _drafts│ └── _posts└── themes!$ npm install # 安装依赖# 推荐博主的依赖:https://removeif.github.io/theme/%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81%E5%88%86%E4%BA%AB.html# 把博主帖子最后的package.json内容复制到你的package.json文件中再执行npm install$ hexo g$ hexo s 更换hexo主题 更换hexo主题 >folded12345678# 以Amazing为例$ cd Blog$ git clone https://github.com/removeif/hexo-theme-amazing.git themes/amazing$ vim _config.yml # 注释:这个_config.yml是Blog文件夹下的.yml文件,不是刚才下载的那个# 修改主题# theme: amazing$ cd ./theme/amazing$ npm install #安装主题的依赖,这个在clone的时候package.json这就有内容了 配置主题细节 _config.yml配置文件 >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454# 文件是Blog/theme/amazing/_config.yml# 我只是讲解一些我所配置的东西,很多东西我也不会搞# 版本号version: 4.0.0# Icarus 主题选择: &quot;default&quot; or &quot;cyberpunk&quot;variant: default# 网站Logo的URLlogo: https://cdn.jsdelivr.net/gh/ZhangPF2000/Image@main/img/签名.png# 页面数据配置head: # 博客的icon地址(URL) favicon: https://cdn.jsdelivr.net/gh/ZhangPF2000/Image@main/img/logo.jpg # Open Graph metadata(翻译:打开图形元数据) # https://hexo.io/docs/helpers.html#open-graph open_graph: # Page title (og:title) (optional) # You should leave this blank for most of the time title: ZhangPF2000 # Page type (og:type) (optional) # You should leave this blank for most of the time type: blog # Page URL (og:url) (optional) # You should leave this blank for most of the time url: https://ZhangPF2000.github.io/ # Page cover (og:image) (optional) # You should leave this blank for most of the time image: https://i1.hdslb.com/bfs/face/e2ddc2275df94af1cebf7028aa1bdc1bb30e78f4.jpg # Site name (og:site_name) (optional) # You should leave this blank for most of the time site_name: ZhangPF2000 # Page author (article:author) (optional) # You should leave this blank for most of the time author: ZhangPF2000 # Page description (og:description) (optional) # You should leave this blank for most of the time description: # Twitter card type (twitter:card) twitter_card: # Twitter ID (twitter:creator) twitter_id: # Twitter Site (twitter:site) twitter_site: # Google+ profile link (deprecated) google_plus: # Facebook admin ID fb_admins: # Facebook App ID fb_app_id: # Structured data of the page # https://developers.google.com/search/docs/guides/intro-structured-data # 这个可以不填 structured_data: # Page title (optional) # You should leave this blank for most of the time title: # Page description (optional) # You should leave this blank for most of the time description: # Page URL (optional) # You should leave this blank for most of the time url: # Page author (article:author) (optional) # You should leave this blank for most of the time author: # Page images (optional) # You should leave this blank for most of the time image: # Additional HTML meta tags in an array # 这个也可以不填 meta: # Meta tag specified in &lt;attribute&gt;=&lt;value&gt; style # E.g., name=theme-color;content=#123456 =&gt; &lt;meta name=&quot;theme-color&quot; content=&quot;#123456&quot;&gt; - '' # URL or path to the website's RSS atom.xml rss: # Page top navigation bar configurationsnavbar: # Naviagtion menu items menu: # 这个地方把&quot;Home&quot;改成&quot;主页&quot;就可以在页面显示中文菜单了(全部都改,后面的/和/tags之类的不要动) 主页: / 归档: /archives 分类: /categories 标签: /tags 影音: /media 相册: /album 友链: /friend # 留言: /message # 碎碎念: /self-talking # 音乐: /music 关于: /about # Links to be shown on the right of the navigation bar links: # 这两个链接是页面右上的搜索那个位置(搜索左边有一个github和四条竖杠的图表) # 不推荐动 Join Gitter: # 这个是amazing论坛,里面有些对amazing主题的交流,可以去看看 icon: fab fa-gitter url: 'https://gitter.im/hexo-theme-amazing/community' Download on GitHub: # 这个是amazing的下载链接 icon: fab fa-github url: 'https://github.com/removeif/hexo-theme-amazing'# Page footer configurationsfooter: # Links to be shown on the right of the footer section # 这个也不推荐动 links: # 这个是右下角的三个图标 # 一个圆圈cc # 一个圆圈小人 # 一个github图表 Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' Attribution 4.0 International: icon: fab fa-creative-commons-by url: 'https://creativecommons.org/licenses/by/4.0/' Download on GitHub: icon: fab fa-github url: 'https://github.com/removeif/hexo-theme-amazing'# Article related configurationsarticle: # Code highlight settings highlight: # Code highlight themes # https://github.com/highlightjs/highlight.js/tree/master/src/styles theme: atom-one-light # Show copy code button clipboard: true # Default folding status of the code blocks. Can be &quot;&quot;, &quot;folded&quot;, &quot;unfolded&quot; fold: unfolded # Whether to show estimated article reading time readtime: true # Article licensing block licenses: Creative Commons: icon: fab fa-creative-commons url: 'https://creativecommons.org/' Attribution: icon: fab fa-creative-commons-by url: 'https://creativecommons.org/licenses/by/4.0/' Noncommercial: icon: fab fa-creative-commons-nc url: 'https://creativecommons.org/licenses/by-nc/4.0/'# Search plugin configurations# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Search/# 这个是搜索设置(我没动过,还是有的好)search: type: insight# Comment plugin configurations# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Comment/# 下面这些是评论设置:我没啥空去搞这个评论# 目前也不打算搞这个,有需要的去https://removeif.github.io/theme/%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81%E5%88%86%E4%BA%AB.html博主贴子看看如何设置# 我全部都注释掉了#comment:# type: disqus# # Disqus shortname# shortname: ''# Comment plugin configurations# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Comment/#comment:# type: gitalk# language: zh-CN #zh-CN #Localization language key, en, zh-CN and zh-TW are currently available.# owner: removeif # (required) GitHub user name# repo: blog_comment # (required) GitHub repository name# client_id: 46a9f34ea0129d8 # (required) OAuth application client id# client_secret: 79c7c9cb847e141757d78bcbf89f0655b24 # (required) OAuth application client secret# admin: ['removeif']# create_issue_manually: true# distraction_free_mode: false# has_hot_recommend: true # 是否有热门推荐# has_latest_comment: true #是否有最新评论 # comment:# type: valine# app_id: rOtVIhvG3kd7QaSU9R-gzGzoHsz# app_key: F2sNV0Ckqvb3DEn3z# notify: false# verify: false# avatar: 'mp'# placeholder: '留下您的高见！'# has_latest_comment: true #是否有最新评论 true-有，false-无# owner: 辣椒の酱 #博主名 最新评论标注[博主]# required_fields: ['nick', 'mail', 'link']# lang: en #zh-CN zh-TW en ja# utteranc site: https://utteranc.es/# comment:# type: utteranc# repo: removeif/utteranc_comment # (required) GitHub userName &amp; repository name# issue_term: pathname # issue_number: # label: # theme: github-light# Donate plugin configurations# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Donation/#donates: # 支付宝和微信支付的图标 # 我注释掉了 # 一般是在文章的最下面的位置 # Alipay donate button configurations #- # Donation entry name #type: alipay # Qrcode image URL #qrcode: 'https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190802135456.png' #- # Donation entry name #type: wechat # Qrcode image URL #qrcode: 'https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190802135550.png' # 其他支付.... # &quot;Buy me a coffee&quot; donate button configurations# -# type: buymeacoffee# # URL to the &quot;Buy me a coffee&quot; page# url: ''# # Patreon donate button configurations# -# type: patreon# # URL to the Patreon page# url: ''# # Paypal donate button configurations# -# type: paypal# # Paypal business ID or email address# business: ''# # Currency code# currency_code: USD# # Wechat donate button configurations# -# type: wechat# # Wechat qrcode image URL# qrcode: ''# Share plugin configurations# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/Share/# 分享设置:我没咋动过share: type: sharejs # URL to the ShareThis share plugin script install_url: ''# Sidebar configurations.# Please be noted that a sidebar is only visible when it has at least one widget# 下面这些好像是设置整体布局的# 我感觉自带的布局就挺好,没动,需要的请自行设置然后预览一下看看sidebar: # Left sidebar configurations left: # Whether the sidebar sticks to the top when page scrolls sticky: true # Right sidebar configurations right: # Whether the sidebar sticks to the top when page scrolls sticky: false# Sidebar widget configurations# http://ppoffice.github.io/hexo-theme-icarus/categories/Widgets/widgets: # Table of contents widget configurations - # Where should the widget be placed, left sidebar or right sidebar position: left type: toc # Select show index index: false # Profile widget configurations - # Where should the widget be placed, left sidebar or right sidebar position: left type: profile # Author name # 页面左边的那个大大的作者名 author: ZhangPF2000 # Author title # 作者的标题 author_title: 大二宅男 # Author's current location # 作者位置 location: 浦东新区 # URL or path to the avatar image # 那个大大的头像 avatar: https://cdn.jsdelivr.net/gh/ZhangPF2000/Image@main/img/logo.jpg # Whether show the rounded avatar image avatar_rounded: true # Email address for the Gravatar gravatar: # URL or path for the follow button follow_link: 'https://github.com/ppoffice' # Links to be shown on the bottom of the profile widget social_links: # &quot;关注我&quot;下面的几个图标 Github: icon: fab fa-github url: 'https://github.com/ZhangPF2000' #Weibo: #icon: fab fa-weibo #url: 'https://weibo.com/removeif' Email: icon: fa fa-envelope url: 'mailto:2812827294@qq.com' #Next: #icon: fab fa-dribbble #url: 'https://removeif.github.io/remove.io' RSS: icon: fas fa-rss url: /atom.xml has_hitokoto: true # Recommendation links widget configurations - # Where should the widget be placed, left sidebar or right sidebar position: left type: links # Names and URLs of the sites # 网站链接,自己添加几个喜欢的网站(只显示域名) links: Hexo: 'https://hexo.io' bilibili: 'https://space.bilibili.com/476971740' amazing: 'https://github.com/removeif/hexo-theme-amazing' #Bulma: 'https://bulma.io' # Latest comment widget configurations - # Where should the widget be placed, left sidebar or right sidebar position: right type: latest_comment # Recent posts widget configurations - # Where should the widget be placed, left sidebar or right sidebar position: right type: recent_posts # Categories widget configurations - # Where should the widget be placed, left sidebar or right sidebar position: right type: categories # Archives widget configurations - # Where should the widget be placed, left sidebar or right sidebar position: right type: archives # Tags widget configurations - # Where should the widget be placed, left sidebar or right sidebar position: right type: tags # Google FeedBurner email subscription widget configurations - # Where should the widget be placed, left sidebar or right sidebar position: right type: subscribe_email # Hint text under the email input description: # Feedburner ID feedburner_id: '' # Google AdSense unit configurations - # Where should the widget be placed, left sidebar or right sidebar position: right type: adsense# AdSense client ID#adsense_client_id: #'ca-pub7634'# AdSense AD unit ID#adsense_slot_id: '5588'# article head ad#article_head_has_ad: true# comment head ad#comment_head_has_ad: true# other ad#index_zero_position_ad: true#index_ad_positions: 2,5,9 #首页adsense放置广告的位置，尽量少配置些，多了有可能不显示。一位的时候，加个逗号，如1,或者1,5,9# Plugin configurations# https://ppoffice.github.io/hexo-theme-icarus/categories/Plugins/plugins: # Enable page startup animations animejs: true # Show the &quot;back to top&quot; button back_to_top: true # Baidu Analytics plugin settings # https://tongji.baidu.com baidu_analytics: # Baidu Analytics tracking ID tracking_id: # BuSuanZi site/page view counter # https://busuanzi.ibruce.info busuanzi: true # CNZZ statistics # https://www.umeng.com/web cnzz: # CNZZ tracker id id: # CNZZ website id web_id: # Enable the lightGallery and Justified Gallery plugins gallery: true # Google Analytics plugin settings # https://analytics.google.com google_analytics: # Google Analytics tracking ID tracking_id: # Hotjar user feedback plugin # https://www.hotjar.com/ hotjar: # Hotjar site id site_id: # Enable the KaTeX math typesetting supprot # https://katex.org/ katex: false # Enable the MathJax math typesetting support # https://www.mathjax.org/ mathjax: false # Enable the Outdated Browser plugin # http://outdatedbrowser.com/ outdated_browser: false # Show a progress bar at top of the page on page loading progressbar: true# CDN provider settings# https://ppoffice.github.io/hexo-theme-icarus/Configuration/Theme/speed-up-your-site-with-custom-cdn/providers: # Name or URL template of the JavaScript and/or stylesheet CDN provider cdn: loli # Name or URL template of the webfont CDN provider fontcdn: loli # Name or URL of the fontawesome icon font CDN provider iconcdn: loli # https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@v1.0.6/json_data/record.json, cdn前缀，对于hexo new page 页面中引用的资源文件不生效，需要手动改，如friend友链页中引用的资源 # my_cdn_pre: https://cdn.jsdelivr.net/gh/removeif/removeif-demo@v1.0.8/ #https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@v2.2.1#footer_copyright_dsec: © 版权说明：[本网站所有内容均收集于互联网或自己创作,&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;方便于网友与自己学习交流，如有侵权，请&lt;a href=&quot;/message&quot; target=&quot;_blank&quot;&gt;留言&lt;/a&gt;，立即处理]&lt;br /&gt; #footer 版权说明 可自由配置website_start_time: 2018/11/11 00:00:00 #网站运行开始时间,不填不显示#footer_registered_no: 川ICP备88888888号-8（测试） #备案号#side_music_netease_id: 2364053447 #侧边栏网易云歌单idbusuanzi_only_count: false #当上面plugins中busuanzi: true时，此配置busuanzi_only_count为true时，网站不显示不蒜子统计数据，但是会每次统计。false时显示统计数据。has_live_2D_switch: true #live2D开关 true-开 false-关use_pjax: true #是否pjax#-----------------------# 这些是我自己对页面设置的一些配置# 更加详细的内容请看博主的帖子:https://removeif.github.io/theme/%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81%E5%88%86%E4%BA%AB.html#----------------------- 配置hexo _config.yml配置文件 >folded123456789101112131415161718192021222324252627282930313233# 这个_config.yml文件是在Blog下的,是配置hexo的,要和配置主题的_config.yml区分开来# 配置完主题就可以设置一些hexo的东西了(配置主题和配置hexo的顺序可以调换过来)# URL## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'# 注意:这个地方不要设置成# https://zhangpf2000.github.io/root# root: /root# 博主也没设置,如果添加上root或其他,会导致部分博客其他某些地方出现错误,无法加载数据资源等url: https://zhangpf2000.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls: trailing_index: true # Set to false to remove trailing 'index.html' from permalinks trailing_html: true # Set to false to remove trailing '.html' from permalinks# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: amazing# 使用主题: amazing# Deployment# 这个是使用github的时候设置的## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repo: https://github.com/ZhangPF2000/ZhangPF2000.github.io.git branch: main Github github >folded12345671-&gt;注册帐号2-&gt;创建&lt;username&gt;.github.io仓库3-&gt;配置好git用户名/邮箱和ssh设置,确保你的git能链接到你的github4-&gt;配置_config.yml中的远程仓库信息5-&gt;hexo clean6-&gt;hexo g7-&gt;hexo d 希望能对你有所帮助 (p_o)","link":"/2021/03/13/Hexo-Github-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html/"}],"tags":[{"name":"fcitx5","slug":"fcitx5","link":"/tags/fcitx5/"},{"name":"debian","slug":"debian","link":"/tags/debian/"},{"name":"kde plasma","slug":"kde-plasma","link":"/tags/kde-plasma/"},{"name":"fcitx","slug":"fcitx","link":"/tags/fcitx/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"生活琐事","slug":"生活琐事","link":"/tags/%E7%94%9F%E6%B4%BB%E7%90%90%E4%BA%8B/"},{"name":"Bash","slug":"Bash","link":"/tags/Bash/"},{"name":"codewars","slug":"codewars","link":"/tags/codewars/"},{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"docker","slug":"docker","link":"/tags/docker/"}],"categories":[{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"fcitx","slug":"linux/fcitx","link":"/categories/linux/fcitx/"},{"name":"bug","slug":"linux/bug","link":"/categories/linux/bug/"},{"name":"Bash","slug":"linux/Bash","link":"/categories/linux/Bash/"},{"name":"codewars","slug":"codewars","link":"/categories/codewars/"},{"name":"python","slug":"codewars/python","link":"/categories/codewars/python/"},{"name":"cpp","slug":"codewars/cpp","link":"/categories/codewars/cpp/"},{"name":"docker","slug":"linux/docker","link":"/categories/linux/docker/"},{"name":"shell","slug":"codewars/shell","link":"/categories/codewars/shell/"}]}